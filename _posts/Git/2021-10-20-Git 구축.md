---
title:  "Git 구축"
excerpt: "Git 구축 입니다."

categories:
  - git
tags:
  - [git, gitgub]

toc: true
toc_sticky: true

last_modified_at: 2022-10-20T20:00:00-05:00
---

## STEP1. Git 설치 
먼저 깃을 설치한다. Ubuntu, Debian 등의 데비안 계열 리눅스에서는 다음 명령어로 설치한다.

```bash
sudo apt-get update
sudo apt-get install git

```


## STEP2. Git 설정
설치가 완료되면, 깃을 사용하기 전에 몇 가지 설정을 해야 합니다. 사용자 이름과 이메일 주소를 설정합니다. 이 정보는 깃에서 커밋(commit)을 할 때 사용됩니다.

```bash
git config --global user.name "blang"  #"사용자 이름"
git config --global user.email "layup3@naver.com" # "사용자 이메일 주소"

```


## STEP3. 깃 사용

> ***들어가기전에)***  
>   
> 기본적인 사용 흐름은 다음과 같을 것이다.
> 1. git status
> 2. git add .
> 3. git commit -m "주저리주저리"
> 4. git push [repo alias] [branch]
> 5. ID/PW 또는 ID/Access-token 입력
> 

이제 깃을 사용할 준비가 되었습니다. 먼저 로컬(local) 저장소(repository)를 만들어보겠습니다.
```bash
mkdir ~/myproject
cd myproject
git init

# 또는 아래와 같은 방법도 가능하다.
# 이미 만들어진 원격레파지토리 클론
git clone https://github.com/bck/dclock.github.io.git

```
  
위 명령어를 입력하면 myproject 폴더가 생성되고, 이 폴더에서 깃 저장소를 초기화합니다. 이제 파일을 추가하고 커밋해보겠습니다.  
{: .notice--info}
  
```bash
touch README.md
git add README.md
git commit -m "초기 커밋"

```
  
README.md 파일을 추가하고, add 명령어를 통해 변경 사항을 스테이징(staging) 영역으로 이동시킵니다. 마지막으로 commit 명령어를 사용하여 변경 내용을 커밋합니다.

>
> ***커밋취소에대하여)***  
> ```bash
> git log --oneline
> 8538197 (HEAD -> main) 리액트프로젝트 커밋
> 3963c38 (origin/main, origin/HEAD) second 커밋
> 3f8be4e first 커밋
>
> ```
> 
> 위 내용에서 마지막 커밋이 잘못되어 second 커밋으로 돌아가야한다.
> 
> ```bash
> git reset [--option(hard/soft/mixed)] [commit]
>
> ```
>option :  
> - hard : 돌아간 커밋 이후의 변경 이력을 전부 삭제  
> - soft : 변경 이력 삭제, 변경 내용은 남아있음, 인덱스 초기화(git add가 안되어 있는 상태)  
> - mixed : 변경 이력 삭제, 변경 내용은 남이있음, 인덱스도 유지(git add까지 되어 있음) 디폴트 값이다.    
>   
> 요약하면 아래와 같이 수행하면 커밋을 취소할 수 있다.
> 
> ```bash
> git reset --mixed HEAD~1
> or
> git reset --mixed second 커밋
> or
> git reset HEAD~1
> or
> git reset 3963c38
>
> ```
>   
> 다음과 같이 변했다.
> 
> ```bash
> git log --oneline
> 963c38 (HEAD -> main, origin/main, origin/HEAD) second 커밋
> 3f8be4e first 커밋
>
> ```
> 그리고 다음과 같이 add 하라는 상태를 확인할 수 있다.
> 
> ```bash
> git status
> 현재 브랜치 main
> 브랜치가 'origin/main'에 맞게 업데이트된 상태입니다.
> 
> 추적하지 않는 파일:
>   (커밋할 사항에 포함하려면 "git add <파일>..."을 사용하십시오)
> 
>         blang-react-pages/
> 
> 커밋할 사항을 추가하지 않았지만 추적하지 않는 파일이 있습니다 > (추적하려면 "git add"를 사용하십시오)
>
> ```


## STEP4. 리모트(remote) 저장소에 연결
이제 로컬 저장소에 파일을 추가하고 커밋하는 것은 성공적으로 수행되었습니다. 하지만 이제 이 프로젝트를 다른 사람과 협업하기 위해서는 리모트 저장소(remote repository)와 연결해야 합니다. 먼저 연결할 리모트 저장소의 URL을 알아야 합니다.  

만약 GitHub에서 새로운 레파지토리를 만든 경우, 해당 레파지토리의 URL은 다음과 같습니다.  

```bash
https://github.com/사용자 이름/레파지토리 이름.git

```

이제 로컬 저장소와 리모트 저장소를 연결합니다.

```bash
git remote add origin https://github.com/사용자 이름/레파지토리 이름.git

```

## STEP5. 변경 사항 푸시
이제 로컬 저장소의 변경 내용을 리모트 저장소에 푸시(push)합니다.

```bash
git push -u origin main

```

로컬저장소에 커밋된 파일을 원격저장소에 최종업로드 한다. 참고로 업로드 도중 본인의 GitHub 아이디와 비밀번호 인증을 통과해야 업로드가 성공적으로 완료된다. 


## STEP6. Git ID/PW(Access-token) 매번 입력에서 벗어나기
ID/PW 또는 ID/Access-token 입력 없이 push 할 수 있는 방법을 작성한다.
> 참고블로그) [https://tomatohj.tistory.com/20](https://tomatohj.tistory.com/20)

### 방법1. Credential 정보를 반영구 저장 하는 방식
```bash
# [이 과정의 경우 기존에 세팅된 credential.helper 데이터를 해제할 때만 사용한다.]
git config --unset credential.helper 

# 이부분이 핵심이다.
# ※참고) store 된 데이터는 따로 설정해 주지 않았다면 ~/.git-credentials에 저장됨
git config credential.helper store


git pull
# username과 password 를 입력하면 credential로 저장된다.
# credentials 은 디스크에 저장되며 일반 유저들도 사용가능하다.
# paintext 일반 텍스트로 저장된다.
# cat ~/.git-credentials 으로 확인 가능하다.
# password가 바뀐경우 git 은 ~/.git-credentials을 지우고 다시 usernamer과 password를 물어볼것이다.
# 다시 git pull하라.

```


### 방법2. Credential 정보를 특정 시간동안 git cache에 임시로 저장하는 방식-
```bash
git config --unset credential.helper # [이 과정의 경우 기존에 세팅된 credential.helper 데이터를 해제할 때만 사용한다.]

# 이부분이 핵심이다.
git config credential.helper cache
git config credential.helper 'cache --timeout 7200'  # [초단위 이며, 필요에 따라 변경한다. Default는 900초]

# ※참고) --global 옵션을 추가할 경우 모든 repository에 대하여 적용할 수 있다.


```


### 정리
차이가 있다면  

1. store 방식은 반 영구적으로 저장하기 때문에, 계속해서 인증정보를 입력하지 않아도 되는 상태가 유지되지만,
2. cache 방식은 특정 시간동안만 그 상태가 유지된다. 

취향에 맞게본인이 원하는 형태의 방식을 사용하면 되겠다.  
이제 다시 add, commit 과정을 거친뒤 push 해보자.  
정말 편하지 않은가... (인증정보를 로컬에 저장하기 때문에 보안적으로 추천드리는 방법은 아님)  
