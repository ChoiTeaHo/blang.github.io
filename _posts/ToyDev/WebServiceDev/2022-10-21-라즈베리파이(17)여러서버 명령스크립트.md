---
title:  "라즈베리파이(17) 여러서버 명령스크립트"
excerpt: "라즈베리파이(17) 여러서버 명령스크립트 입니다."
categories:
  - web-service-dev
tags:
  - [web, dev]
toc: true
toc_sticky: true

last_modified_at: 2022-10-12T20:00:00-05:00
---

# 라즈베리파이 여러서버 명령스크립트
## ssh 개요
  : 라즈베리파이에 구축한 Apache 1대 & Tomcat 2대 서버로 한번에 명령어를 수행한다.

> ***ssh 명령어***  
> 다른 서버로 붙을 수 있는 명령어.  
> 현재 나도 스마트폰 ssh로 각 서버에 붙어서 작업하고 있으며, 이번에는 스마트폰을 통해 붙은 리눅스 안에서 다시 ssh 명령어를 수행하는 차이일뿐 기능의 본질은 똑같다. 

/sshd
{: .notice--info}


## ssh 스크립트
  : 여러 서버에 ssh 명령어를 나열한 스크립트를 생성한다.

### web서버1
  : 스크립트 생성

  ```bash
  # 여러서버들을 핸들하고싶은 특정서버에다가 생성
  vi ~/script/dbd/server_hostname.sh
  
  #!/bin/bash
  echo "웹1.... >>>"  
  sudo ssh wasadm@blang.co.kr -p [웹서버포트] sudo hostname -I  

  echo "와스2.... >>>"  
  sudo ssh wasadm@blang.co.kr -p [와스1서버포트] sudo hostname -I  

  echo "와스1.... >>>"  
  sudo ssh dbd000@blang.co.kr -p [와스2서버포트] sudo hostname -I  

  ```


  1. 스크립트 생성  
    : 브라우져에 신뢰할 수 있는 기관으로 등록되어 있지 않는 곳에서 발급받았기 때문에 사용할 때 경고 메세지 등을 보고 예외처리를 해준더가 해야한다.
      - ex) `openSSL`

  2. 인증기관이 무료로 제공하는 인증서 유형  
    :  보통은 큰 업체들이 인증서 사용을 권장하기 위해 후원하는 식이다.  
      - ex)`starssl`, `Let’s Encrypt`

  > 1. Let’s Encrypt : https://letsencrypt.org/
  > 2. Comodo Free SSL : https://www.gogetssl.com/domain-validation/comodo-free-ssl/  
  > 3. CloudFlare One-Click SSL : https://www.cloudflare.com/ssl/  
  > 4. AWS Certificate Manager : https://aws.amazon.com/ko/certificate-manager/  
  > 5. (귄장되지 않음) StartCom StartSSL : https://www.startssl.com/  
  > 6. (권장되지 않음) self-signed 인증서  
  >   : OpenSSL을 이용해 자체적으로 루트 CA를 생성해서 self-signed 인증서를 발급받는 것.

### 유료인증서 종류
  : 말그대로 유료 구매하면 끝이다. (SS 인증서를 발급을 돕는 호스팅업체는 너무 많으므로 생략한다.)

### 차이점
  : CA 중에서는 VeriSign이나 Codomo와 같이 `유료 SSL인증서`를 발급하는 곳이 있고 Let's Encrypt와 같이 `무료 인증서`를 발급해주는 곳이 있다. 유료와 무료 SSL 인증서 간에 기술적 차이점은 없다. 하지만 SSL인증서를 적용한 사이트에 인증과 관련한 문제가 생겼다면 `유료 인증서`를 발급한 곳에서는 해당 웹사이트를 방문한 사람에게 SSL인증서를 구매한 회사를 대신해 일정 부분 금액을 배상한다. 비싼 인증서는 보상의 범위와 규모가 커지고 싼 인증서는 보상의 범위와 규모가 상대적으로 작습니다. `무료 인증서`는 CA에서 이러한 배상을 해주지 않는다.

### 최종선택
  : 적용할 SSL 유형을 선택한다. 나는 무료인증서를 적용하기로 했다.

- 후보1. OpenSSL  
  : 보통 테스트용도로는 `OpenSSL` 을 이용하는것으로 보인다. 이는 위에서 설명한 `Self signed certificate` 방식의 SSL 인증서를 발급이다.

  > ***Self signed Certificate(SSC) 란?***  
  > 모든 인증서는 발급기관(CA)가 있어야 하나, 최상위에 있는 인증기관(root ca)은 서명해줄 상위 인증기관이 없으므로 root ca의 개인키로 스스로의 인증서에 서명하여 최상위 인증기관 인증서를 만든다. 이렇게 스스로 서명한 root ca 인증서를 Self Signed Certificate 라고 한다.  
  > IE, FireFox, Chrome 등의 Web Browser 제작사는 VeriSign 이나 comodo 같은 유명 ROOT CA 들의 인증서를 신뢰하는 CA이다. 
  >   
  > 이런 CA는 미리 등록해 놓으므로 저런 기관에서 발급된 SSL 인증서를 사용해야 browser 에서는 해당 SSL 인증서를 신뢰할수 있는데,
  > OpenSSL 로 만든 ROOT CA와 SSL 인증서는 Browser가 모르는 기관이 발급한 인증서이므로 보안 경고를 발생시킬 것이나 테스트 사용에는 지장이 없다.
  > 딱 이정도 수준이다.

- 후보2. Let’s Encrypt 
  : 무료이지만 테스트스럽지 않은 이 인증서로 결정했다. 단 3개월마다 갱신이 필요하다는 단점이 있다. 

  - Let's Encrypt의 경우는 조건없이 무료이다.
  - 하지만 EV 인증서는 발급받을 수 없다.
  - 지속적으로 https 인증서를 유지하려면 3개월마다 갱신해야한다.
  - 보통 crontab으로 자동 갱신한다.

  ***참고)Let's Encrypt (현재 Certbot 명칭)***  
  `Let's Encrypt` 는 최근에 `certbot` 으로 패키지 이름이 변경되었다. Ubuntu 내부적으로 `Let's Encrypt` -> `certbot` 으로 설정되어 있으니, 둘 중 아무 단어나 사용해도 무방하다. (동작이 완전히 동일함)
  {: .notice--info}


## SSL 구축
  : SSL(Let's Encrypt)을 구현한다. 수동 컴파일로 설치한 apache 서버에 SSL 인증서 적용한다.
 
>  ***주의) 들어가기전에..***  
>  아파치를 소스컴파일로 수동설치한 나의 케이스는 대중적으로 사용하는 간단한 명령어로 인증서받기가 불가능하다.

### 웹서버 로드밸런싱 (JkMount) 매핑 설정
  : 우선 SSL 적용하는 곳은 웹서버이다. 그런데 현재 모든 요청이 WAS 측으로 넘어가도록 로드밸런싱 되어있다. 특정 요청은 넘어가지 않도록 JkMount 매핑을 설정해주도록 한다.

  1. (웹서버루트/conf/httpd.conf) 설정  
    : 아래 코드를 추가해준다.

      ```bash
      
      
      
      ```

      꼭 WAS1, WSA2 모두 적용시켜주도록 한다.  
      별 다른이야기는 없고 `<Receiver>` 태그에서 주소와 포트가 각각 다르게 설정했음을 알 수 있다. 
      {: .notice--info}

      
  2. (웹프로젝트루트/WEB-INF/web.xml) 설정  
    :  웹프로젝트 web.xml에서 태그를 추가한다. 

      ```bash
      <web-app>

      (중략)

      <welcome-file-list>
        <welcome-file>/WEB-INF/index.html</welcome-file>
      </welcome-file-list>

      <distributable/> <!-- 이 부분을 추가한다 -->
      </web-app>

      ```

      ***주의)***  
      헷갈리지말자 웹프로젝트안에 있는 web.xml 이다.
      {: .notice--info}
     
### 테스트
  : 서버 재기동 후 정상인지 테스트한다. 사전에 세션ID를 찍는 테스트 jsp 를 만들어주어야한다. (테스트페이지 작성은 생략했다. 세션 GET 하고 출력과 동시에 서버를 구분할 수 있는 문자열 정도만 넣어주면된다.) 

  1. 리스너 정상 확인  
    : 앞서 `<Receiver>` 태그에 각각 다르게 작성한 포트 4000(또는 4001) 이 정상적으로 작동하고있다.  
 
      ```bash 
      ================> netstat -anp | grep java
      tcp6       0      0 :::18009                :::*                    LISTEN      9089/java
      tcp6       0      0 192.168.0.10:4000       :::*                    LISTEN      9089/java
      tcp6       0      0 ::1:8005                :::*                    LISTEN      9089/java
      tcp6       0      0 192.168.0.10:4000       192.168.0.12:40842      ESTABLISHED 9089/java
      tcp6       0      0 192.168.0.10:47266      192.168.0.12:4001       ESTABLISHED 9089/java
      udp6       0      0 :::45564                :::*                                9089/java
      unix  2      [ ]         STREAM     CONNECTED     205781   9089/java
      unix  2      [ ]         STREAM     CONNECTED     205777   9089/java
      
      ```

  2. 테스트페이지 접속   
    : => WAS1 또는 WAS2 안에 있는 페이지를 호출해서 세션이 맺어짐을 확인한다. (나는 WAS1 로 들어가졌다.)

      ```
      # 테스트페이지에 찍힌 WAS1 쿠키세션 정보
      6B941D9A646C9BD55350E230E536C50A.tomcat1

      ```
  
  3. 테스트페이지 새로고침 해본다  
    : => 분명 똑같은 WAS1 서버로 요청할것이다. 여기까지 sticky 밸런싱 정상작동임을 확인했다.

  4. was1 서버를 강제로 중지시킨다.  
    : => WAS1서버에 세션이 맺어졌으므로 WAS1서버를 중지한다. (세션클러스터링 세션복사 확인을 위해)
     
      ```bash
      # (WAS1 에서 수행)

      # 와스 중지 스크립트 실행
      wasstop
      Using CATALINA_BASE:   /fswas/tomcat/apache-tomcat-8.5.82
      Using CATALINA_HOME:   /fswas/tomcat/apache-tomcat-8.5.82
      Using CATALINA_TMPDIR: /fswas/tomcat/apache-tomcat-8.5.82/temp
      Using JRE_HOME:        /usr
      Using CLASSPATH:       /fswas/tomcat/apache-tomcat-8.5.82/bin/bootstrap.jar:/fswas/tomcat/apache-tomcat-8.5.82/bin/tomcat-juli.jar
      Using CATALINA_OPTS:
      
      # 정상적으로 중지되었다.
      cat localhost.2022-12-02.log                                     02-Dec-2022 10:11:51.268 정보 [localhost-startStop-2] org.apache.catalina.core.ApplicationContext.log SessionListener: contextDestroyed()
      02-Dec-2022 10:11:51.269 정보 [localhost-startStop-2] org.apache.catalina.core.ApplicationContext.log ContextListener: contextDestroyed()
      02-Dec-2022 10:11:51.335 정보 [localhost-startStop-2] org.apache.catalina.core.ApplicationContext.log SessionListener: contextDestroyed()
      02-Dec-2022 10:11:51.335 정보 [localhost-startStop-2] org.apache.catalina.core.ApplicationContext.log ContextListener: contextDestroyed()

      ```

  5. 테스트페이지 새로고침 해본다  
    : => 이번엔 바라보던 WAS1 서버가 죽었기에 WAS2 서버로 요청할것이다. 여기까지 로드밸런싱 정상작동임을 확인했다.
  
  6. WAS2 서버의 catalina.out 로그를 확인해본다.  
     : => WAS1의 세션을 복사하는 로그가 찍힌다.

      ```bash
      # (WAS1 에서 수행)

      # 로그확인
      cd /fswas/tomcat/apache-tomcat-8.5.82/logs
      vi catalina.out

      (중략)
      # 세션 복제가 확인된다! (WAS를 재기동 해야 찍힌다.)
      02-Dec-2022 11:10:17.274 정보 [Membership-MemberAdded.] org.apache.catalina.ha.tcp.SimpleTcpCluster.memberAdded 복제 멤>버가 추가됨: [org.apache.catalina.tribes.membership.MemberImpl[tcp://{192, 168, 0, 12}:4001,{192, 168, 0, 12},4001, alive=60555, securePort=-1, UDP Port=-1, id={30 49 -94 -59 -25 -32 64 -119 -97 -109 38 -94 -118 11 -48 -56 }, payload={}, command={}, domain={}]]

      ```

  6. 다시 테스트페이지로 접속  
    : ==> 서버는 달라졌지만 복제되어 동일한 세션ID가 찍히는지 확인한다.
 
      ```
      # 테스트페이지에 찍힌 WAS2 쿠키세션 정보
      # (fail 된 WAS1 의 세션과 동일한것을 볼 수 있다!.)
      6B941D9A646C9BD55350E230E536C50A.tomcat2

      ```
   
  7. 정상

  

### 세션클러스터링 적용완료

> 톰캣을 이용한 로드밸런싱과 세션 클러스터링에 대해서 알아보았다. 
> 일반적으로 로드밸런싱과 클러스터링은 성능 향상이라는 측면과 안정성 확보에 그 목적을 가지고 있다.
> 물론 고가의 상용 웹 어플리케이션 서버에 비하면 많이 부족하고 
> 하드웨어를 이용한 로드밸런싱과 클러스터링에 비하면 안정성이 떨어질 수도 있지만 
> 저렴한 비용으로 최대의 안정성과 성능을 얻고자 한다면 한번쯤 시도해 볼만한 좋은 기능이라고 할 수 있다.
