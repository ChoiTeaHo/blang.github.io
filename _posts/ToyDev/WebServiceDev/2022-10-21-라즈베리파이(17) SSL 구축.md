---
title:  "라즈베리파이(17) SSL 구축"
excerpt: "라즈베리파이(17) SSL 구축 입니다."
categories:
  - web-service-dev
tags:
  - [web, dev]
toc: true
toc_sticky: true

last_modified_at: 2022-10-12T20:00:00-05:00
---

# 라즈베리파이 SSL 구축
## SSL 개요
  : 라즈베리파이에 구축한 Apache & Tomcat서버에 SSL을 적용한다.

> ***SSL(HTTP over Secure Socket Layer) 요약***  
> 이제는 당연시 되어버린 https.  
> 기존 `http`는 암호화되지 않은 방식으로 데이터를 주고 받기 때문에 제 3자에 의한 악의적인 해킹에 취약했다. 
> `https`는 제 3자인 CA(인증기관)가 보증하는 문서를 통해 보안 통신을 제공한다. 이 문서를 `SSL 인증서`라 한다.
> 정리하면 `https`는 SSL 프로토콜 위에서 돌아가는 프로토콜이며 `SSL`은 데이터를 안전하게 전송하기 위한 인터넷 통신 규약 프로토콜이다.
> `SSL`은 2.0과 3.0 버전을 거쳐 현재는 SSL 3.0을 기반으로한 TLS가 도입되어 사용 중이다.
>   
> SSL 2.0 / SSL 3.0 은 2015년을 마지막으로 중지되었으며, 
> TLS는 현재 TLS 1.2 / TLS 1.3 의 버전이 존재한다. (2020년 5월 업데이트로 TLS 1.0 및 TLS 1.1 프로토콜 지원 중지되었다.)
> TLS 1.2 이상을 지원하지 않는 웹 서버를 운영 중이라면, 업그레이드를 해야한다.

SSL과 TLS는 같은 말이며, SSL이라는 이름이 오래 사용된 탓인지 TLS에 비해 SSL이라는 이름으로 많이 사용되고 있다.
{: .notice--info}


## SSL 과정

  L4 스위치의 경우 사용자는 접속했던 WAS로 접속을 유도해주지만 하나의 WAS에서 허용된 동접수를 초과한 접속이 발생할 경우 다른쪽으로의 접속을 유도해주게 됩니다.
  {: .notice--info}


## 세션클러스터링 구축
### 아파치재단에서 말하는 세션클러스터링 구축
  : 아파치사의 mod_jk 는 세션클러스터링에 대해 다음과 같은 특징을 가진다고 한다.

> - multicast 방식으로 동작하며 address는 `228.0.0.4`, port는 `45564`를 사용하고 서버 IP는 java.net.InetAddress.getLocalHost().getHostAddress()로 얻어진 IP 값으로 송출됩니다.
> - 먼저 구동되는 서버부터 4000 ~ 4100 사이의 TCP port를 통해 reqplication message를 listening합니다.
> - Listener는 ClusterSessionListener, interceptor는 TcpFailureDetector와 MessageDispatchInterceptor가 설정됩니다.


### WAS서버 세션클러스터링 설정
  : 와스서버(톰캣) 측에서 변경 작업을 한다.

  1. (톰캣루트/conf/server.xml) 설정  
    : 클러스터링 관련 내용 주석을 해제하고 설정을 작성한다.

      ![사진1](/assets/images/ToyDev/WebServiceDev/tomcat_session_cluster_1.jpg)

      `<Cluster>` 태그 사이에는 `<Membership>`, `<Receiver>`, `<Sender>` 라는 3개의 태그가 위치한다.   
      - `<Membership>`: 멤버 그룹을 정의 하는 것으로 해당 값이 동일한 모든 톰캣 프로세스는 클러스터로묶이게 된다. 
      - `<Receiver>`: 클러스터 그룹에서 보내오는 메시지와 세션 정보 등을 받아오는 것이며
      - `<Sender>`: 자신의 세션 정보 및 메시지를 전송하는 것이다.  
  
   
      ```bash
      # (WAS 1번에서 작성)

      <Cluster className="org.apache.catalina.ha.tcp.SimpleTcpCluster" channelSendOptions="8">
      <Manager className="org.apache.catalina.ha.session.DeltaManager" expireSessionsOnShutdown="false" notifyListenersOnReplication="true"/>
      <Channel className="org.apache.catalina.tribes.group.GroupChannel">

        <Membership className="org.apache.catalina.tribes.membership.McastService"
                    address="228.0.0.4"
                    port="45564"
                    frequency="500"
                    dropTime="3000"/>
        <Receiver className="org.apache.catalina.tribes.transport.nio.NioReceiver" 
                    address="192.168.0.10"  #(변경) 라즈베리파이 톰캣서버 주소를 입력한다.
                    port="4000"             #(변경) WAS가 한대에서 처리되어 IP가 동일하다면 다르게 설정한다. (나는 그냥 다르게 설정했다.)
                    autoBind="100" 
                    selectorTimeout="5000"
                    maxThreads="6"/>
        <Sender className="org.apache.catalina.tribes.transport.ReplicationTransmitter">
          <Transport className="org.apache.catalina.tribes.transport.nio.PooledParallelSender"/>
        </Sender>
        <Interceptor className="org.apache.catalina.tribes.group.interceptors.TcpFailureDetector"/>
        <Interceptor className="org.apache.catalina.tribes.group.interceptors.MessageDispatchInterceptor"/>
      </Channel>

      <Valve className="org.apache.catalina.ha.tcp.ReplicationValve" filter=""/>
      <Valve className="org.apache.catalina.ha.session.JvmRouteBinderValve"/>
     
      <Deployer className="org.apache.catalina.ha.deploy.FarmWarDeployer" 
                tempDir="/tmp/war-temp/"
                deployDir="/tmp/war-deploy/"
                watchDir="/tmp/war-listen/"
                watchEnabled="false"/>

      <ClusterListener className="org.apache.catalina.ha.session.ClusterSessionListener"/>
      </Cluster>

      ```
  
  
      ```bash
      # (WAS 2번에서 작성)

      <Cluster className="org.apache.catalina.ha.tcp.SimpleTcpCluster" channelSendOptions="8">
      <Manager className="org.apache.catalina.ha.session.DeltaManager" expireSessionsOnShutdown="false" notifyListenersOnReplication="true"/>
      <Channel className="org.apache.catalina.tribes.group.GroupChannel">

        <Membership className="org.apache.catalina.tribes.membership.McastService"
                    address="228.0.0.4"
                    port="45564"
                    frequency="500"
                    dropTime="3000"/>
        <Receiver className="org.apache.catalina.tribes.transport.nio.NioReceiver" 
                    address="192.168.0.12" 
                    port="4001" 
                    autoBind="100" 
                    selectorTimeout="5000"
                    maxThreads="6"/>
        <Sender className="org.apache.catalina.tribes.transport.ReplicationTransmitter">
          <Transport className="org.apache.catalina.tribes.transport.nio.PooledParallelSender"/>
        </Sender>
        <Interceptor className="org.apache.catalina.tribes.group.interceptors.TcpFailureDetector"/>
        <Interceptor className="org.apache.catalina.tribes.group.interceptors.MessageDispatchInterceptor"/>
      </Channel>

      <Valve className="org.apache.catalina.ha.tcp.ReplicationValve" filter=""/>
      <Valve className="org.apache.catalina.ha.session.JvmRouteBinderValve"/>
     
      <Deployer className="org.apache.catalina.ha.deploy.FarmWarDeployer" 
                tempDir="/tmp/war-temp/"
                deployDir="/tmp/war-deploy/"
                watchDir="/tmp/war-listen/"
                watchEnabled="false"/>

      <ClusterListener className="org.apache.catalina.ha.session.ClusterSessionListener"/>
      </Cluster>

      ```

      꼭 WAS1, WSA2 모두 적용시켜주도록 한다.  
      별 다른이야기는 없고 `<Receiver>` 태그에서 주소와 포트가 각각 다르게 설정했음을 알 수 있다. 
      {: .notice--info}

      
  2. (웹프로젝트루트/WEB-INF/web.xml) 설정  
    :  웹프로젝트 web.xml에서 태그를 추가한다. 

      ```bash
      <web-app>

      (중략)

      <welcome-file-list>
        <welcome-file>/WEB-INF/index.html</welcome-file>
      </welcome-file-list>

      <distributable/> <!-- 이 부분을 추가한다 -->
      </web-app>

      ```

      ***주의)***  
      헷갈리지말자 웹프로젝트안에 있는 web.xml 이다.
      {: .notice--info}
     
### 테스트
  : 서버 재기동 후 정상인지 테스트한다. 사전에 세션ID를 찍는 테스트 jsp 를 만들어주어야한다. (테스트페이지 작성은 생략했다. 세션 GET 하고 출력과 동시에 서버를 구분할 수 있는 문자열 정도만 넣어주면된다.) 

  1. 리스너 정상 확인  
    : 앞서 `<Receiver>` 태그에 각각 다르게 작성한 포트 4000(또는 4001) 이 정상적으로 작동하고있다.  
 
      ```bash 
      ================> netstat -anp | grep java
      tcp6       0      0 :::18009                :::*                    LISTEN      9089/java
      tcp6       0      0 192.168.0.10:4000       :::*                    LISTEN      9089/java
      tcp6       0      0 ::1:8005                :::*                    LISTEN      9089/java
      tcp6       0      0 192.168.0.10:4000       192.168.0.12:40842      ESTABLISHED 9089/java
      tcp6       0      0 192.168.0.10:47266      192.168.0.12:4001       ESTABLISHED 9089/java
      udp6       0      0 :::45564                :::*                                9089/java
      unix  2      [ ]         STREAM     CONNECTED     205781   9089/java
      unix  2      [ ]         STREAM     CONNECTED     205777   9089/java
      
      ```

  2. 테스트페이지 접속   
    : => WAS1 또는 WAS2 안에 있는 페이지를 호출해서 세션이 맺어짐을 확인한다. (나는 WAS1 로 들어가졌다.)

      ```
      # 테스트페이지에 찍힌 WAS1 쿠키세션 정보
      6B941D9A646C9BD55350E230E536C50A.tomcat1

      ```
  
  3. 테스트페이지 새로고침 해본다  
    : => 분명 똑같은 WAS1 서버로 요청할것이다. 여기까지 sticky 밸런싱 정상작동임을 확인했다.

  4. was1 서버를 강제로 중지시킨다.  
    : => WAS1서버에 세션이 맺어졌으므로 WAS1서버를 중지한다. (세션클러스터링 세션복사 확인을 위해)
     
      ```bash
      # (WAS1 에서 수행)

      # 와스 중지 스크립트 실행
      wasstop
      Using CATALINA_BASE:   /fswas/tomcat/apache-tomcat-8.5.82
      Using CATALINA_HOME:   /fswas/tomcat/apache-tomcat-8.5.82
      Using CATALINA_TMPDIR: /fswas/tomcat/apache-tomcat-8.5.82/temp
      Using JRE_HOME:        /usr
      Using CLASSPATH:       /fswas/tomcat/apache-tomcat-8.5.82/bin/bootstrap.jar:/fswas/tomcat/apache-tomcat-8.5.82/bin/tomcat-juli.jar
      Using CATALINA_OPTS:
      
      # 정상적으로 중지되었다.
      cat localhost.2022-12-02.log                                     02-Dec-2022 10:11:51.268 정보 [localhost-startStop-2] org.apache.catalina.core.ApplicationContext.log SessionListener: contextDestroyed()
      02-Dec-2022 10:11:51.269 정보 [localhost-startStop-2] org.apache.catalina.core.ApplicationContext.log ContextListener: contextDestroyed()
      02-Dec-2022 10:11:51.335 정보 [localhost-startStop-2] org.apache.catalina.core.ApplicationContext.log SessionListener: contextDestroyed()
      02-Dec-2022 10:11:51.335 정보 [localhost-startStop-2] org.apache.catalina.core.ApplicationContext.log ContextListener: contextDestroyed()

      ```

  5. 테스트페이지 새로고침 해본다  
    : => 이번엔 바라보던 WAS1 서버가 죽었기에 WAS2 서버로 요청할것이다. 여기까지 로드밸런싱 정상작동임을 확인했다.
  
  6. WAS2 서버의 catalina.out 로그를 확인해본다.  
     : => WAS1의 세션을 복사하는 로그가 찍힌다.

      ```bash
      # (WAS1 에서 수행)

      # 로그확인
      cd /fswas/tomcat/apache-tomcat-8.5.82/logs
      vi catalina.out

      (중략)
      # 세션 복제가 확인된다! (WAS를 재기동 해야 찍힌다.)
      02-Dec-2022 11:10:17.274 정보 [Membership-MemberAdded.] org.apache.catalina.ha.tcp.SimpleTcpCluster.memberAdded 복제 멤>버가 추가됨: [org.apache.catalina.tribes.membership.MemberImpl[tcp://{192, 168, 0, 12}:4001,{192, 168, 0, 12},4001, alive=60555, securePort=-1, UDP Port=-1, id={30 49 -94 -59 -25 -32 64 -119 -97 -109 38 -94 -118 11 -48 -56 }, payload={}, command={}, domain={}]]

      ```

  6. 다시 테스트페이지로 접속  
    : ==> 서버는 달라졌지만 복제되어 동일한 세션ID가 찍히는지 확인한다.
 
      ```
      # 테스트페이지에 찍힌 WAS2 쿠키세션 정보
      # (fail 된 WAS1 의 세션과 동일한것을 볼 수 있다!.)
      6B941D9A646C9BD55350E230E536C50A.tomcat2

      ```
   
  7. 정상
  

### 세션클러스터링 적용완료

> 톰캣을 이용한 로드밸런싱과 세션 클러스터링에 대해서 알아보았다. 
> 일반적으로 로드밸런싱과 클러스터링은 성능 향상이라는 측면과 안정성 확보에 그 목적을 가지고 있다.
> 물론 고가의 상용 웹 어플리케이션 서버에 비하면 많이 부족하고 
> 하드웨어를 이용한 로드밸런싱과 클러스터링에 비하면 안정성이 떨어질 수도 있지만 
> 저렴한 비용으로 최대의 안정성과 성능을 얻고자 한다면 한번쯤 시도해 볼만한 좋은 기능이라고 할 수 있다.
