---
title:  "리액트 설치 및 기본구성(폐쇄망)"
excerpt: "리액트 설치 및 기본구성(폐쇄망) 입니다."

categories:
  - react
tags:
  - [react]

toc: true
toc_sticky: true

last_modified_at: 2023-04-05T20:00:00-05:00
---

## 리액트 수동설치(폐쇄망)
```bash
# 수동설치 결과
├── package.json
├── node_modules
├── public
│   ├── index.html  # react 의 기본구조 /public/웰컴파일 필수
└── src
     └── index.js   # react 의 기본구조 /src/리액트트실행파일 필수

```
> 폐쇠망환경은 인터넷이 안되기에 <span style="color:blue"><b>npx create-react-app 프로젝트이름</b></span> 명령어는 사용할 수 없다.  
> 방법은 외부에서 셋팅한 모듈을 가지고 리액트 프로젝트를 구축해야한다.  
> <span style="color:red"><b>폐쇠망은 이미 모듈이 구축된 환경을 만든뒤에 start 하는 방법으로 진행해야한다</b></span>.


### STEP1. NODE 설치
```bash
# package.json 1개의 파일이 생성되어짐.
npm init -y

```


### STEP2. node_modules 직접 준비
```bash
# 외부에서 리액트 모듈을 포함한 node_modules 디렉토리를 준비.
# npm init 시킨 프로젝트 ROOT 디렉토리에 위치시킨다.
unzip node_modules.zip

```

앞서 설명한 것처럼 최소 기본조건 모듈만 준비하면 된다.
- react 모듈
- react-dom 모듈 
- react-scripts 모듈


### STEP3. (index.js) 리액트앱 엔트리포인트JS 작성
리액트 앱의 진입점(엔트리 포인트)을 만들어야 한다. 즉, [리액트 앱 코드]를 직접 작성한다.  
기본적으로 내부 설정에서 디폴트 경로가 정해져있다.
  
***과정***  
- <span style="color:green"><b>[루트]/src</b></span> 디렉토리를 생성.
- 그 안에 <span style="color:green"><b>[루트]/src/index.js</b></span> 파일을 작성.

```bash
mkdir /src
touch /src/index.js  # Entry Point [React APP] 파일작성

```

```js
// src/index.js
import React from 'react';
import ReactDOM from 'react-dom';

const App = () => {
  return (
    <div>
      <h1>Hello, React!</h1>
    </div>
  );
};

ReactDOM.render(<App />, document.getElementById('root'));

```


### STEP4. (index.html) 리액트앱 메인HTML 템플릿 작성
  
<span style="color:blue">***이 파일은 React 애플리케이션의 시작점이며, JavaScript 코드 실행의 진입점이다.***</b></span>
  
1. ReactDOM.render() 함수를 사용하여 React 컴포넌트를 렌더링하는 역할. 
2. 이 파일에서는 React 앱의 루트 컴포넌트를 실제로 DOM에 렌더링
3. 즉, src/index.js 파일에서는 ReactDOM.render()를 통해 public/index.html의 루트 엘리먼트 내에 React 컴포넌트들이 렌더링


***과정***  
폐쇄망에서는 모든것을 개발자가 직접 생성해야하므로 리액트 앱의 진입점(엔트리 포인트)을 만들어야 한다. 
- <span style="color:green"><b>[루트]/src</b></span> 디렉토리를 생성.
- 그 안에 <span style="color:green"><b>[루트]/src/index.js</b></span> 파일을 작성.

```bash
mkdir /src
touch /src/index.js  # Entry Point [React APP] 파일작성

``` 


### STEP5. React 앱 실행
react-scripts 모듈 명령을 사용하여 실행스크립트를 명명하고, 개발 서버를 실행한다.
```bash
# package.json
{
  "scripts": {
    "start": "react-scripts start"
  }
}

```
```bash
# 일반적인 리액트 개발서버 실행(react-scripts 모듈의 기능)
npx react-scripts start

# 실행 스크립트 생성으로 개발서버 실행
npm start

```


### 정리
개발 서버가 성공적으로 실행되면, 브라우저에서 http://localhost:3000에 접속하여 리액트 앱을 확인할 수 있다. <span style="color:red"><b>이렇게 수동으로 리액트 프로젝트를 설치하고 실행 가능</b></span>하다. <span style="color:red"><b>그러나 npx create-react-app 명령어를 사용하는 것이 더 간편하고 권장되는 방법</b></span>이다.



## 스텝별 에러 발생 정리 (참고용)
폐쇄망 환경에서 절차적으로 스타트 해본결과 발생한 이슈를 정리하면 다음과 같다.


### 파일 관련 에러가 발생
```bash
# 에러내용
# 루트/piblic/index.html 파일이 존재해야한다. (기본 웰컴 파일이 있어야 하나보다.) 
npx react-scripts start
 Could not find a required file.
  Name: index.html
  Searched in: C\Users\MT01301\Desktop\react-study\public

# (/piblic/index.html 추가 후 해결)

# 루트/src/index.js 파일이 존재해야한다. (기본 실행파일이 있어야 하나 보다.)
npx react-scripts start
 Could not find a required file.
  Name: index.js
  Searched in: C\Users\MT01301\Desktop\react-study\src
      
# (/src/index.js 추가 후 해결)

```

### 프록시 관련 에러가 발생
    
```json
// package.json
// 환경에 맞는 [프록시]디펜던시 추가
{
  "dependencies": {
    "proxy": "http://stg.kbfg.in"  //prod
    //"proxy": "http://dev.kbfg.in"  //local, dev
  }
}

```
<b>***이렇게 하니 폐쇄망 환경에서 정상적으로 리액트가 구동되었다.***</b>  
{: .notice--info}

> <span style="color:blue"><I><b>프록시에 대해서 알아가기</b></I></span>
> ```js
> //server.js
> const express = require('express');
> const httpProxy = require('http-proxy');
>   
> const app = express();
> const proxy = httpProxy.createProxyServer();
> 
> app.use(express.static(__dirname + '/public'));
> 
> app.all('/api/*', function(req, res) {
>   // 스프링부트 서버 URL
>   proxy.web(req, res, { target: 'http://localhost:8080' });
> });
> 
> app.listen(3000, function() {
>   console.log('Proxy server is running on port 3000');
> });
> 
> ```
> 1. 위 코드에서는 Express를 사용하여 3000번 포트에서 Proxy 서버를 구동하며, 모든 /api/* URL로 요청이 들어오면 8080번 포트로 프록시하여 요청을 전달한다. 이 때, 프록시할 서버의 URL은 http://localhost:8080 으로 지정한다.
> 2. 이렇게 프록시 서버를 구축했다면, 리액트앱에서 프록시를 사용하도록 package.json 파일에 proxy 옵션을 등록하면 끝이다.
>   
>   
> ___
> 다른방법도 있다.  
> http-proxy-middlewar 으로 프록시서버를 만들고 리액트앱에서 AXIOS 을 통해 
> API 요청을 Ajax URL Proxy 설정하는 예시이다.
> ```js
> //server.js
> const express = require('express');
> const { createProxyMiddleware } = require('http-proxy-middleware');
> 
> const app = express();
> const port = process.env.PORT || 3001;
> 
> const apiProxy = createProxyMiddleware('/api', {
>   // 스프링부트 서버 URL  
>   target: 'http://localhost:8080', 
>   changeOrigin: true,
> });
> 
> app.use('/api', apiProxy);
> 
> app.listen(port, () => {
>   console.log(`Proxy server listening on port ${port}`);
> });
> 
> ```
> 위처럼 http-proxy-middlewar 으로 프록시서버를 만들고 
> ```bash
> # (1)설치
> npm install axios --save
> ```
>  
> 리앱트 앱측에선 XIOS 으로 API 요청을 Ajax URL Proxy 를 한다.
> 
> ```ts
> // (2)AXIOS 사용
> import axios from 'axios';
> 
> const API_BASE_URL = '/api'; // Ajax URL Proxy 서버 URL
> 
> const ApiService = {
>   get(endpoint) {
>     return axios.get(`${API_BASE_URL}${endpoint}`);
>   },
> 
>   post(endpoint, data) {
>     return axios.post(`${API_BASE_URL}${endpoint}`, data);
>   },
> 
>   // 기타 HTTP 메소드
> };
> 
> export default ApiService;
> 
> ```
> 
> 위 코드에서 API_BASE_URL 변수를 Ajax URL Proxy 서버 URL로 설정한다. 
> 그리고 Axios 요청 시, URL 앞에 API_BASE_URL을 붙여 Ajax URL Proxy를 
> 통해 요청을 보낸다. 
> 이제 React 앱에서 Ajax URL Proxy를 사용해 스프링부트 앱과 통신할 수 있게된다.
> 


### 시작시 Error: error:0308010C:digital envelope routines::unsupported
이 내용은 만약 발생한다면 아래와 같이 조치한다. 
  - react, react-dom, react-scripts 패키지를 하나하나씩 업그레이드해보면서 react-scripts의 버전 문제 이슈가 있다고함.
  - package.json의 scripts에서 start 명령어에 옵션을 주어 임시방편으로 해결하는 방법으로 해결이 안되는 사례도 있다고 한다.
  - 다음과 같이 환경변수를 설정 하여 `npx react-scripts start` 수행
      ```bash
      # 환경변수 추가

      # 윈도우
      set NODE_OPTIONS=--openssl-legacy-provider
      echo %NODE_OPTIONS%

      # 리눅스
      export NODE_OPTIONS=--openssl-legacy-provider
      echo %NODE_OPTIONS%

      ```
  - 또는 다음과 같이 실행스크립트에 ssl 관련 환경변수를 설정하여 `npm start` 수행
      ```json
      # package.json
      {
        "scripts": {
          "start": "react-scripts --openssl-lagacy-provider start"
        }
      }

      ```



## JS코드 구조
### public/index.html
```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta
      name="description"
      content="Web site created using create-react-app"
    />
    <link rel="apple-touch-icon" href="%PUBLIC_URL%/logo192.png" />
    <!--중략-->
    <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
    <!--중략-->
    <title>React App</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
    <!--중략-->
  </body>
</html>

```

이 파일은 웹의 메인 페이지 이다.  
react를 하면서 여러 컴포넌트들을 만들어 나간다.  
이때 create-react는 여기 마지막 줄 근처에 div id ="root" 안에 들어가도록 약속되어 있다.

### src/index.js 
```js
import App from './App';  // 컴포넌트 호출
// (중략)
const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);

```

이 파일은 엔트리포인트인 main() 이다.  
`document.getElementById('root')` 이 부분은 index.html에서의 #root 부분에 해당 한다. 현재 <App /> 라는 사용자정의태그를 호출하고 있다.


### src/App.js
```js
import logo from './logo.svg';
import './App.css';

function App() {
  return (
    <div className="App">
      <header className="App-header">
        <img src={logo} className="App-logo" alt="logo" />
        <p>
          Edit <code>src/App.js</code> and save to reload.
        </p>
        <a
          className="App-link"
          href="https://reactjs.org"
          target="_blank"
          rel="noopener noreferrer"
        >
          Learn React
        </a>
      </header>
    </div>
  );
}

export default App;

```

이 파일은 리액트 기본구성에 들어있던 App 이라는 컴포넌트이다.
즉, 리턴되는 내용을 불러와서 메인 화면을 구성한 것이다. 

## CSS 코드 적용
### src/index.css
```css
body {
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

code {
  font-family: source-code-pro, Menlo, Monaco, Consolas, 'Courier New',
    monospace;
}

/* 추가 CTH */
button {
  background-color: #4CAF50;
  color: white;
  border: none;
  border-radius: 4px;
  padding: 8px 16px;
  margin-left: 10px;
  cursor: pointer;
  font-size: 16px;
}
.button-gray {background-color: #A9A9A9;}
button:hover {background-color: #3e8e41;}
.button-gray:hover {background-color: #F09438;}

```

추가하고 서버를 재기동하면 버튼에 대한 스타일이 잘 적용된다.  
지금 디폴트로 css파일이 위치한 경로는 src 경로에 있는데 <span style="color:red"><b>일반적으로 src/styles 디렉토리 안에 index.css 파일을 위치</b></span>시키고, 해당 파일에서 전역적으로 사용되는 스타일을 정의한다고 한다.



## 리액트 배포
### npm run build
F12 창에서 페이지 갱신하고 확인해보면 기본인데 리소스가 많이 잡아먹는다. (예를들면 hello react라는 문자만 넣었다고 가정하면 1.8MB나 된다.) 
현재 리액트는 개발의 편의성을 위해서 여러 가지 기능들을 추가해놓은 상태이기 때문에, 상<span style="color:red"><b>당히 무거운 편</b></span>이다. <span style="color:red"><b>이 파일을 그대로 유저가 이용하게 된다면 상당히 느려질 것</b></span>이다.

```bash
npm run build


tree
.
├── package.json
├── package-lock.json
├── bck # 리액트 앱 CREATE 한 프로젝트
│   ├── build  # 이 폴더가 생겼다 ! 
│   ├── README.md
│   ├── node_modules
│   ├── package-lock.json
│   ├── package.json
│   ├── public
│   └── src
└── node_modules

```

build라는 디렉토리가 새로 생긴다.  
이 안에 index.html을 열어보면 이상하게 나온다. 원래 사용했던 index.html 의 내용 등에서 불필요한 공백들과 같이 용량을 차지하는 녀석들을 전부 다 제거한다. <span style="color:red"><b>즉, 실제 서비스할 때는 build 안에 있는 파일들을 사용</b></span>하면 된다. 

### 백엔드에서 build 사용하기

1. Node.js(Express) 서버 환경  
    : 예를 들어 Node.js 기반의 Express 를 백엔드 서버로 쓴다면 다음과 같다ㅇ

    ```js  
    // 정적 파일이 모인 build 폴더를 static 으로 설정
    app.use(express.static(path.join(__dirname, '../ucb-front/build')));
    
    ```  
    ```bash
    # express의 엔트리 파일을 실행
    npm run start 

    ```
    <span style="color:red"><b>React 앱이 빌드된 정적 파일이 모인 build 폴더를 static 으로 설정 하면 끝이다.</b></span>   
    Express 서버에서 /ucb-front/build URL 경로로 요청이 들어오면 ../ucb-front/build 디렉토리에 있는 파일들을 클라이언트에게 제공하게 된다. 이를 통해 React 앱이 빌드된 정적 파일들을 Express 서버에서 호스팅할 수 있다.

2. 간단한 웹서버 환경(serve 모듈)
    : npm 에서 serve 라는 모듈을 사용한다면 다음과 같다.

    ```bash
    npm insatll serve
    npx serve -s build   # 한번만 실행

    # 기본 5000 포트를 사용한다.

      ┌──────────────────────────────────────────┐
      │                                                                  │
      │   Serving!                                                       │
      │                                                                  │
      │   - Local:    http://localhost:3000                              │
      │   - Network:  http://192.168.0.10:3000                           │
      │                                                                  │
      └──────────────────────────────────────────┘

    HTTP  2023. 4. 20. 오후 5:56:52 223.62.22.82 GET /
    HTTP  2023. 4. 20. 오후 5:56:52 223.62.22.82 Returned 200 in 227 ms
    HTTP  2023. 4. 20. 오후 5:56:53 223.62.22.82 GET /static/js/main.ae67edd3.js
    HTTP  2023. 4. 20. 오후 5:56:53 223.62.22.82 GET /static/css/main.f2eabf11.css
    HTTP  2023. 4. 20. 오후 5:56:53 223.62.22.82 Returned 200 in 17 ms
    HTTP  2023. 4. 20. 오후 5:56:53 223.62.22.82 Returned 200 in 26 ms
    HTTP  2023. 4. 20. 오후 5:56:53 223.62.22.82 GET /static/media/logo.6ce24c58023cc2f8fd88fe9d219db6c6.svg
    HTTP  2023. 4. 20. 오후 5:56:53 223.62.22.82 GET /logo192.png
    HTTP  2023. 4. 20. 오후 5:56:53 223.62.22.82 Returned 200 in 8 ms
    HTTP  2023. 4. 20. 오후 5:56:53 223.62.22.82 Returned 200 in 7 ms
    HTTP  2023. 4. 20. 오후 5:56:53 223.62.22.82 GET /favicon.ico
    HTTP  2023. 4. 20. 오후 5:56:53 223.62.22.82 Returned 200 in 4 ms
    
    ```

    serve는 node.js로 초간단하게 설치해서 실행 시킬 수 있는 웹서버 라고 할 수 있다. 주로 정적 파일을 호스팅하기 위해 사용한다.
    
    사용하는 이유는 다음과 같다.  
    - 로컬 개발 환경에서 정적 파일 또는 SPA를 쉽게 실행할 수 있다. 
    - 소규모 프로젝트나 프로토타입 개발에 적합하다.
    - Node.js와 연관된 구성 요소를 전혀 사용하지 않고 간단한 개발 서버를 실행할 수 있다.
    - 커스텀 설정으로 개발 서버를 확장할 수 있다.
    
    > 
    > <span style="color:blue"><b>***npm start VS serve 차이점***</b></span>  
    > npm start와 serve는 비슷한 역할을 수행하지만 목적이 다르다.  
    >   
    > <span style="color:green"><b>**npm start**</b></span>  
    > - package.json 파일의 scripts 섹션에서 start 키워드로 설정된 명령어를 실행하는 것 
    > - 로컬 개발 서버를 시작하고 애플리케이션을 브라우저에서 실행시킨다.
    > - 보통 React 프로젝트에서는 start 스크립트가 react-scripts start 명령어를 
    > 실행행하도록 설정되어 있다.   
    >  
    > <span style="color:green"><b>**serve**</b></span>  
    > - 정적 파일 서버를 시작하는 데 사용되는 도구. 
    > - 이를 사용하면 빌드된 React 애플리케이션을 서비스할 수 있다. 
    > - serve는 배포된 애플리케이션을 실행하는 데 유용하다.
    >   
    > <span style="color:red"><b>따라서 개발 중인 React 애플리케이션을 실행할 때는 npm start를 사용하고, 배포된 
    > 애플리케이션을 실행할 때는 serve를 사용하는 것이 적합하다.</b></span>   
    > 
    > 개발 서버에서 코드가 변경되면 자동으로 업데이트되어 새로고침 없이 바로 변경 사항을 확인할 수 있는 기능을 <span style="color:red"><b>핫리로딩</b></span> 이라고 한다. 그러나 <span style="color:red"><b>serve와 같은 정적 파일 서버를 사용하면 핫 리로딩 기능을 사용할 수 없다.</b></span> 이는 정적 파일 서버가 요청을 받으면 해당 파일을 반환하고, 서버에서 동적인 코드 실행 없이 파일을 그대로 전달하기 때문이다. 따라서 핫 리로딩 기능을 사용하려면 개발 서버에서 정적 파일 서버 대신에 코드를 실행하고 변경 사항을 자동으로 감지하여 적용할 수 있는 방법을 사용해야 한다.  
    대표적인 예시로는 webpack-dev-server가 있다.


    






### (1) 버튼 추가하기
```js
// src/index.js
import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css';
import App from './App';
import reportWebVitals from './reportWebVitals';

// 익명의 컴포넌트 추가
const MyButton = () => {
  return (
    <button>나는 버튼이야.</button>
  );
};


const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <App />
    <MyButton />
  </React.StrictMode>
);

reportWebVitals();

```




### test_MyComponent.tsx
```tsx
import React from 'react';

// 함수형 컴포넌트 예시
const MyComponent: React.FC<PropsType> = ({ prop1, prop2 }) => {
  return (
    <div>
      <h1>Hello, World!</h1>
      <p>prop1: {prop1}</p>
      <p>prop2: {prop2}</p>
    </div>
  );
}

// 클래스형 컴포넌트 예시
class MyComponent extends React.Component<PropsType> {
  render() {
    const { prop1, prop2 } = this.props;
    return (
      <div>
        <h1>Hello, World!</h1>
        <p>prop1: {prop1}</p>
        <p>prop2: {prop2}</p>
      </div>
    );
  }
}

// 컴포넌트에 전달되는 props의 타입을 정의한 예시
type PropsType = {
  prop1: string;
  prop2: number;
}

export default MyComponent;

```

### main.tsx
```tsx
// 다른 파일에서 MyComponent를 import하여 사용하는 예시

// MyComponent.tsx 파일에서 export default로 내보낸 컴포넌트를 import하여 사용
import MyComponent from './MyComponent';

// MyComponent 컴포넌트를 사용하는 예시
const App = () => {
  return (
    <div>
      <MyComponent prop1="Hello" prop2={123} />
    </div>
  );
}

export default App;

```

```tsx
// 동일 파일 내에서 MyComponent를 사용하는 예시

import React from 'react';

const MyComponent: React.FC<PropsType> = ({ prop1, prop2 }) => {
  return (
    <div>
      <h1>Hello, World!</h1>
      <p>prop1: {prop1}</p>
      <p>prop2: {prop2}</p>
    </div>
  );
}

const App = () => {
  return (
    <div>
      <MyComponent prop1="Hello" prop2={123} />
    </div>
  );
}

export default App;

```