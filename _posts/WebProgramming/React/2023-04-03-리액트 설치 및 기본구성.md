---
title:  "리액트 설치 및 기본구성"
excerpt: "리액트 설치 및 기본구성 입니다."

categories:
  - react
tags:
  - [react]

toc: true
toc_sticky: true

last_modified_at: 2023-04-03T20:00:00-05:00
---

## 리액트 최소조건 기본실행 모듈
기본적으로 실행하기 위한 최소한 포함되어야 하는 모듈을 소개한다.

### react 모듈
- react  
    : 리액트의 핵심 모듈로, UI 컴포넌트를 생성하고 관리하는 역할을 수행한다. 가상 DOM(Virtual DOM)을 사용하여 성능을 최적화하고, 컴포넌트의 상태(State)와 속성(Props)을 관리하며, 이벤트 처리, 라이프사이클 메서드 등을 제공한다.

### react-dom 모듈 
- react-dom
    : 리액트에서 실제 DOM(Document Object Model)과 상호작용하기 위한 모듈로, 웹 브라우저에서 리액트 애플리케이션을 렌더링하는 역할을 수행한다. DOM 요소를 조작하고, 컴포넌트를 실제 DOM에 렌더링하며, 이벤트 핸들러를 등록하고 관리하는 등의 기능을 제공한다.

    > react와 react-dom은 함께 사용되어, 리액트 애플리케이션을 개발하고 
    > 브라우저에서 실행시키는데 필수적인 모듈이다.  

### react-scripts 모듈
- react-scripts는 React 애플리케이션을 개발, 빌드 및 실행하기 위한 설정 및 스크립트를 제공하는 패키지 이다. Create React App이라는 React 프로젝트를 쉽게 생성하고 개발 환경을 구성하는 도구에서 사용되는 패키지 이다. 특징은 다음과 같다. 

    - <span style="color:green"><b>(1). 개발 서버 (Development Server)</b></span>: react-scripts는 개발용 서버를 제공하여 <span style="color:red"><b>로컬 개발 환경에서 React 애플리케이션을 실행하고 확인</b></span>할 수 있도록 한다. 개발 서버는 코드 변경 시 자동으로 리로드되며, 에러와 경고 메시지를 보여주어 개발 과정을 보다 편리하게 만들어 준다.
        ```bash
        # 개발서버 실행
        cd my-app
        npm start

        ```

    - <span style="color:green"><b>(2). 빌드 스크립트 (Build Scripts)</b></span>: react-scripts는 React 애플리케이션을 배포하기 위한 빌드 스크립트를 제공한다. 이를 통해 애플리케이션 코드를 최적화하고 번들링하여 운영 환경에 배포할 수 있다.
        ```bash
        # 애플리케이션을 배포하기 위해 빌드 스크립트를 실행할 수 있다.
        # 아래 명령어를 통해 애플리케이션을 빌드할 수 있다.
        # 이 명령어는 최적화된 애플리케이션 코드를 생성하고, 배포를 위한 번들 파일들을 생성한다.
        npm run build

        ```

    - <span style="color:green"><b>(3). 웹팩 설정 (Webpack Configuration)</b></span>: react-scripts는 웹팩(Webpack)을 사용하여 React 애플리케이션을 <span style="color:red"><b>번들링하는 설정을 제공</b></span>한다. 웹팩은 모던 자바스크립트, CSS, 이미지 등의 리소스들을 하나의 번들 파일로 묶어서 서버에 제공할 수 있도록 해준다. 웹팩 설정 파일은 일반적으로 프로젝트 루트 디렉토리에 위치하며, 웹팩의 동작 방식, 입력 및 출력 경로, 로더(Loaders)와 플러그인(Plugins) 등을 설정할 수 있다. 요약하면 <span style="color:red"><b>웹팩은 자바스크립트 애플리케이션의 모듈 번들링과 빌드 자동화를 수행하는 모듈 번들러</b></span>이다.

    - <span style="color:green"><b>(4). 개발환경 설정 (Development Environment Configuration)</b></span>: react-scripts는 <span style="color:red"><b>개발 환경을 설정하는 파일들을 제공<b></span>한다. 예를 들어, .env 파일을 통해 환경변수를 설정하거나, .env.local 파일을 통해 로컬 개발 환경에만 적용되는 환경변수를 설정할 수 있다.
        ```bash
        # 이렇게 설정된 환경 변수는 아래와 같이 React 프로젝트에서 접근 가능
        # ex) process.env.REACT_APP_API_URL
        REACT_APP_API_URL=https://api.example.com

        ```

    - (5). react-scripts는 <span style="color:red"><b>Create React App을 통해 생성된 프로젝트에서 기본적으로 사용</b></span>되며, <span style="color:red"><b>React 애플리케이션을 편리하게 개발, 빌드 및 실행</b></span>할 수 있도록 도와준다.
        ```bash
        # Create React App을 통해 프로젝트를 생성하는 것이 가장 일반적인 방법
        # 새로운 React 프로젝트를 생성 가능해짐
        npx create-react-app my-app

        ```

## 리액트에서 엔트리포인트를 찾는 방법
리액트에서 엔트리포인트를 찾는 방법은 <span style="color:blue"><b>webpack.config.js</b></span> 파일에서 entry 항목을 확인하는 것이다. 이 항목은 웹팩이 번들링을 시작할 진입점(entry point)을 지정하는 곳으로, 일반적으로 src/index.js 또는 src/App.js와 같은 파일이 지정된다.
  
<span style="color:red"><I><b>그런데 아무리 뒤져봐도 이 파일이 없다..</b></I></span>  
  
찾아보니 <span style="color:red"><b>엔트리포인트를 내부적으로 설정</b></span>한다고 한다. 
- <span style="color:red"><b>create-react-app 명령어</b></span>로 생성한 React 프로젝트에서는 <span style="color:red"><b>기본적으로 webpack.config.js 파일이 생성되지 않는다.</b></span> 
- 대신에 기본적인 설정은 숨겨져 있는 상태로 <span style="color:red"><b>create-react-app이 내부적으로 Webpack을 사용</b></span>한다
- 만약 Webpack 설정을 커스터마이징하고 싶다면, eject 명령어를 사용하여 create-react-app에서 기본으로 제공하는 설정 파일들을 밖으로 꺼내고, 직접 수정해야 한다.
    - eject 명령어를 사용하여 create-react-app의 내부 설정을 수정하는 것은 비추천
    - 프로젝트 구성이 복잡해지고 업데이트가 어려워질 수 있기 때문
    - react-app-rewired 와 같은 도구를 사용하여 기본 설정을 커스터마이징을 추천한다. 이 방법은 create-react-app 이 제공하는 내부 설정을 직접 수정하지 않고, 커스터마이징된 설정을 사용하여 React 애플리케이션을 빌드할 수 있도록 도와준다.
  
정리하면, create-react-app으로 프로젝트를 생성했다면, <span style="color:blue"><b>src/index.js</b></span> 파일이 엔트리포인트이다. 이 파일에서 ReactDOM.render() 메서드를 호출하여 리액트 컴포넌트를 렌더링한다. 따라서 <span style="color:blue"><b>src/index.js</b></span> 파일에서 <span style="color:red"><b>ReactDOM.render() 메서드를 찾아보면 엔트리포인트를 확인(엔트리 포인트라고 생각해라..)</b></span>할 수 있다.

```js
// src/index.js (설치시 디폴트 내용)
import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css';
import App from './App';
import reportWebVitals from './reportWebVitals';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);

// If you want to start measuring performance in your app, pass a function
// to log results (for example: reportWebVitals(console.log))
// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals
reportWebVitals();


```



## CASE1. 리액트 기본설치(일반적인)
다음과 같이 리액트를 사용하기 위해 별도 학습용 폴더를 생성했다.

```bash
mkdir reactStudy 

```

기본 설치한구조는 다음과 같다.
```bash
.
├── package.json
├── package-lock.json
├── bck # 리액트 앱 CREATE 한 프로젝트
│   ├── README.md
│   ├── node_modules
│   ├── package-lock.json
│   ├── package.json
│   ├── public
│   │   ├── favicon.ico
│   │   ├── index.html # react 의 기본구조 /public/웰컴파일 필수
│   │   ├── logo192.png
│   │   ├── logo512.png
│   │   ├── manifest.json
│   │   └── robots.txt
│   └── src
│        ├── App.css
│        ├── App.js
│        ├── App.test.js
│        ├── index.css
│        ├── index.js  # react 의 기본구조 /src/리액트트실행파일 필수
│        ├── logo.svg
│        ├── reportWebVitals.js
│        └── setupTests.js
└── node_modules

```

### (1) NODE 설치
```bash
# package.json 1개의 파일이 생성되어짐.
npm init -y

tree
.
└── package.json
```

### (2) React 설치
```bash
# React 설치
# npm install -g create-react-app   # 전역 설치
npm install create-react-app        # 일반 설치


tree
.
├── node_modules
├── package-lock.json
└── package.json

```
```json
// package.json
{
  "dependencies": {
    "create-react-app": "^5.0.1", //추가
  }
}

```

### (3) React 앱 생성
```bash
# create-react-app bck    # 전역 설치 시 앱생성(축약)
npx create-react-app bck  # 일반 설치 시 앱생성

tree
.
├── package.json
├── package-lock.json
├── bck # 리액트 앱 CREATE 한 프로젝트
│   ├── README.md
│   ├── node_modules
│   ├── package-lock.json
│   ├── package.json
│   ├── public
│   │   ├── favicon.ico
│   │   ├── index.html # react 의 기본구조 /public/웰컴파일 필수
│   │   ├── logo192.png
│   │   ├── logo512.png
│   │   ├── manifest.json
│   │   └── robots.txt
│   └── src
│        ├── App.css
│        ├── App.js
│        ├── App.test.js
│        ├── index.css
│        ├── index.js  # react 의 기본구조 /src/리액트트실행파일 필수
│        ├── logo.svg
│        ├── reportWebVitals.js
│        └── setupTests.js
└── node_modules

```
> <span style="color:blue"><b>npx create-react-app 프로젝트이름</b></span>  
>  
> 위 명령어를 사용하면 Create React App이라는 공식 리액트 프로젝트 템플릿을 이용하여 새로운 리액트 프로젝트를 생성할 수 있다. 이 명령어를 실행하면, 리액트 프로젝트를 위한 초기 파일과 폴더 구조가 생성되며, 필요한 리액트 라이브러리 및 개발 도구가 자동으로 설치된다. 이후 생성된 프로젝트는 개발 서버를 실행하거나 빌드하여 실제 서버에 배포할 수 있다.  


### (4) React 앱 실행
```bash
# 일반적인 리액트 개발서버 실행(react-scripts 모듈의 기능)
npx react-scripts start

# 실행 스크립트 생성으로 개발서버 실행
npm start

```
![사진1](/assets/images/WebProgramming/NodeJS/react-intro.jpg)  


### 정리
기본 구성을 정리하면 다음과 같다.
- React 앱의 기본 구성은 src 디렉토리 안에 있는 index.js 파일에서 이루어진다. 이 파일에서는 React 앱의 루트 컴포넌트를 정의하고, ReactDOM.render() 함수를 사용하여 컴포넌트를 DOM에 렌더링 한다.
- React에서는 컴포넌트 단위로 앱을 구성한다. 새로운 컴포넌트를 생성하려면 src 디렉토리 안에 새로운 .js 파일을 생성하여 컴포넌트를 정의하면 된다.
- 기본적으로 생성된 React 앱에는 이미 예제 컴포넌트들이 포함되어 있으므로 이를 참고하여 컴포넌트를 생성하면 된다.

무엇보다 create-react-app 기능으로 매우 간단하게 구축했다.  
{: .notice-info}


### 추가) 디폴트 scripts 정리
```json
// package.json
{
  "scripts": {
    "start": "react-scripts start",  
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  },
}

```
기본 설치된 Create React App 에서 기본적으로 등록되어있고 제공하는 scripts 기능을 살펴본다.
1. react-scripts start
    - (기본적이므로 생략)

2. react-scripts build
    - create-react-app으로 만든 프로젝트에서 사용할 수 있다.
    - build 폴더에 빌드된 애플리케이션을 생성한다. 
    - 이 명령어는 애플리케이션을 배포할 때 사용하며, 최적화된 정적 파일을 생성하여 서버로 전송할 수 있도록 한다.
    - react-scripts build 명령어 작업 상세내용
        ```bash
        #STEP0. React 애플리케이션을 로컬에서 개발하고 테스트했다면, 애플리케이션을 실제 웹 서버에 배포해야 하는 상황. 이를 위해서는 빌드(build) 수행
        npx react-scripts build

        # STEP1. build 폴더 생성 되어짐
        # STEP2. 빌드된 애플리케이션 파일들이 해당 폴더에 저장 되어짐. 
        # STEP3. 이제 이 폴더를 웹 서버에 업로드. (FTP, AWS, GCP 등등.)

        ```
        1. 프로덕션 빌드를 위해 애플리케이션 코드를 번들링 한다.
        2. 코드를 최적화하고, 불필요한 코드를 제거 한다.
        3. public 폴더에 있는 정적 파일을 빌드된 애플리케이션 폴더로 복사 한다.
        4. build 폴더에 최종 빌드된 애플리케이션을 생성 한다.
        5. 이렇게 생성된 빌드된 애플리케이션은 [웹 서버에 배포]하여 사용할 수 있다.
            

3. react-scripts test

   ```bash
    npx react-scripts test  #실행

    PASS  src/App.test.js
      ✓ renders learn react link (122 ms)

    Test Suites: 1 passed, 1 total
    Tests:       1 passed, 1 total
    Snapshots:   0 total
    Time:        5.83 s
    Ran all test suites.

    Watch Usage
    › Press f to run only failed tests.
    › Press o to only run tests related to changed files.
    › Press q to quit watch mode.
    › Press p to filter by a filename regex pattern.
    › Press t to filter by a test name regex pattern.
    › Press Enter to trigger a test run.

    ```

    - react-scripts test 명령어는 Create React App에서 제공하는 테스트 러너인 Jest를 실행하는 명령어이다. 
    - 이 명령어는 src 폴더 내부에 있는 파일들 중에서 .test.js나 .spec.js 확장자를 가진 파일들을 찾아서 자동으로 실행한다. 
    - 해당 파일에 대한 테스트를 실행하고, 결과를 콘솔에 출력한다. 
    - Jest는 일반적으로 [유닛 테스트]와 [통합 테스트]를 지원한다. 
      - [유닛 테스트]는 코드의 일부분, 즉 함수나 모듈 등의 작은 단위를 테스트.
      - [통합 테스트]는 전체 시스템이나 애플리케이션의 구성요소들 간의 상호작용을 테스트.
      - Jest는 이 두 가지 유형의 테스트를 모두 지원하며, 또한 describe와 it 함수를 사용하여 테스트 케이스를 작성할 수 있다. 
    - react-scripts test 명령어는 기본적으로 Jest의 Watch 모드로 실행된다. 
      - 이 모드에서는 테스트 파일이 변경될 때마다 자동으로 테스트를 다시 실행한다. 
      - Watch 모드를 끄려면 react-scripts test --no-watch 명령어를 사용한다. 
      - 그리고 --coverage 옵션을 사용하면 테스트 커버리지 정보를 출력할 수 있다.

 
4. react-scripts eject
    - react-scripts eject 명령어는 Create React App으로 만든 프로젝트에서 webpack, Babel 등의 설정 파일을 외부로 분리하여 직접 수정할 수 있게 해주는 명령어. 
    - eject 명령어를 실행하면, Create React App이 생성한 모든 설정 파일이 현재 프로젝트 폴더의 최상위 디렉토리에 복사 된다. 
    - 이후 package.json 파일의 scripts 항목에서 react-scripts 대신 webpack-dev-server 등을 직접 사용할 수 있다.
      > 단, eject 명령어는 되돌릴 수 없으므로, 사용하기 전에는 반드시 백업을 해두는 것이 좋습니다. 또한, 설정 파일을 직접 수정하면서 발생하는 오류는 모두 사용자 책임이므로, 신중하게 사용해야 한다.



## CASE2. 리액트 수동설치(폐쇄망)
```bash
├── package.json
├── node_modules
├── public
│   ├── index.html  # react 의 기본구조 /public/웰컴파일 필수
└── src
     └── index.js   # react 의 기본구조 /src/리액트트실행파일 필수

```
> 폐쇠망환경은 인터넷이 안되기에 <span style="color:blue"><b>npx create-react-app 프로젝트이름</b></span> 명령어는 사용할 수 없다.  
> 방법은 외부에서 셋팅한 모듈을 가지고 리액트 프로젝트를 구축해야한다.  
> <span style="color:red"><b>폐쇠망은 이미 모듈이 구축된 환경을 만든뒤에 start 하는 방법으로 진행해야한다</b></span>.


### (1) NODE 설치
```bash
# package.json 1개의 파일이 생성되어짐.
npm init -y

```


### (2) node_modules 직접 준비
```bash
# 외부에서 리액트 모듈을 포함한 node_modules 디렉토리를 준비.
# npm init 시킨 프로젝트 ROOT 디렉토리에 위치시킨다.
unzip node_modules.zip

```

앞서 설명한 것처럼 최소 기본조건 모듈만 준비하면 된다.
- react 모듈
- react-dom 모듈 
- react-scripts 모듈


### (3) React 앱 코드 작성
이제 필요한 디렉토리와 파일을 생성하고, [리액트 앱 코드]를 직접 작성한다. 예를 들어, src 디렉토리를 생성하고 그 안에 index.js 파일을 작성하여 리액트 앱의 진입점(엔트리 포인트)을 설정한다.

```bash
mkdir /src
touch /src/index.js  # Entry Point [React APP] 파일작성

```

```js
// src/index.js
import React from 'react';
import ReactDOM from 'react-dom';

const App = () => {
  return (
    <div>
      <h1>Hello, React!</h1>
    </div>
  );
};

ReactDOM.render(<App />, document.getElementById('root'));

```

### (4) React 앱 실행
react-scripts 모듈 명령을 사용하여 실행스크립트를 명명하고, 개발 서버를 실행한다.
```bash
# package.json
{
  "scripts": {
    "start": "react-scripts start"
  }
}

```
```bash
# 일반적인 리액트 개발서버 실행(react-scripts 모듈의 기능)
npx react-scripts start

# 실행 스크립트 생성으로 개발서버 실행
npm start

```


### 정리
개발 서버가 성공적으로 실행되면, 브라우저에서 http://localhost:3000에 접속하여 리액트 앱을 확인할 수 있다. <span style="color:red"><b>이렇게 수동으로 리액트 프로젝트를 설치하고 실행 가능</b></span>하다. <span style="color:red"><b>그러나 npx create-react-app 명령어를 사용하는 것이 더 간편하고 권장되는 방법</b></span>이다.



## 스텝별 에러 발생 정리 (참고용)
폐쇄망 환경에서 절차적으로 스타트 해본결과 발생한 이슈를 정리하면 다음과 같다.


### 파일 관련 에러가 발생
```bash
# 에러내용
# 루트/piblic/index.html 파일이 존재해야한다. (기본 웰컴 파일이 있어야 하나보다.) 
npx react-scripts start
 Could not find a required file.
  Name: index.html
  Searched in: C\Users\MT01301\Desktop\react-study\public

# (/piblic/index.html 추가 후 해결)

# 루트/src/index.js 파일이 존재해야한다. (기본 실행파일이 있어야 하나 보다.)
npx react-scripts start
 Could not find a required file.
  Name: index.js
  Searched in: C\Users\MT01301\Desktop\react-study\src
      
# (/src/index.js 추가 후 해결)

```

### 프록시 관련 에러가 발생
    
```json
// package.json
// 환경에 맞는 [프록시]디펜던시 추가
{
  "dependencies": {
    "proxy": "http://stg.kbfg.in"  //prod
    //"proxy": "http://dev.kbfg.in"  //local, dev
  }
}

```
<b>***이렇게 하니 폐쇄망 환경에서 정상적으로 리액트가 구동되었다.***</b>  
{: .notice--info}

> <span style="color:blue"><I><b>프록시에 대해서 알아가기</b></I></span>
> ```js
> //server.js
> const express = require('express');
> const httpProxy = require('http-proxy');
>   
> const app = express();
> const proxy = httpProxy.createProxyServer();
> 
> app.use(express.static(__dirname + '/public'));
> 
> app.all('/api/*', function(req, res) {
>   // 스프링부트 서버 URL
>   proxy.web(req, res, { target: 'http://localhost:8080' });
> });
> 
> app.listen(3000, function() {
>   console.log('Proxy server is running on port 3000');
> });
> 
> ```
> 1. 위 코드에서는 Express를 사용하여 3000번 포트에서 Proxy 서버를 구동하며, 모든 /api/* URL로 요청이 들어오면 8080번 포트로 프록시하여 요청을 전달한다. 이 때, 프록시할 서버의 URL은 http://localhost:8080 으로 지정한다.
> 2. 이렇게 프록시 서버를 구축했다면, 리액트앱에서 프록시를 사용하도록 package.json 파일에 proxy 옵션을 등록하면 끝이다.
>   
>   
> ___
> 다른방법도 있다.  
> http-proxy-middlewar 으로 프록시서버를 만들고 리액트앱에서 AXIOS 을 통해 
> API 요청을 Ajax URL Proxy 설정하는 예시이다.
> ```js
> //server.js
> const express = require('express');
> const { createProxyMiddleware } = require('http-proxy-middleware');
> 
> const app = express();
> const port = process.env.PORT || 3001;
> 
> const apiProxy = createProxyMiddleware('/api', {
>   // 스프링부트 서버 URL  
>   target: 'http://localhost:8080', 
>   changeOrigin: true,
> });
> 
> app.use('/api', apiProxy);
> 
> app.listen(port, () => {
>   console.log(`Proxy server listening on port ${port}`);
> });
> 
> ```
> 위처럼 http-proxy-middlewar 으로 프록시서버를 만들고 
> ```bash
> # (1)설치
> npm install axios --save
> ```
>  
> 리앱트 앱측에선 XIOS 으로 API 요청을 Ajax URL Proxy 를 한다.
> 
> ```ts
> // (2)AXIOS 사용
> import axios from 'axios';
> 
> const API_BASE_URL = '/api'; // Ajax URL Proxy 서버 URL
> 
> const ApiService = {
>   get(endpoint) {
>     return axios.get(`${API_BASE_URL}${endpoint}`);
>   },
> 
>   post(endpoint, data) {
>     return axios.post(`${API_BASE_URL}${endpoint}`, data);
>   },
> 
>   // 기타 HTTP 메소드
> };
> 
> export default ApiService;
> 
> ```
> 
> 위 코드에서 API_BASE_URL 변수를 Ajax URL Proxy 서버 URL로 설정한다. 
> 그리고 Axios 요청 시, URL 앞에 API_BASE_URL을 붙여 Ajax URL Proxy를 
> 통해 요청을 보낸다. 
> 이제 React 앱에서 Ajax URL Proxy를 사용해 스프링부트 앱과 통신할 수 있게된다.
> 


### 시작시 Error: error:0308010C:digital envelope routines::unsupported
이 내용은 만약 발생한다면 아래와 같이 조치한다. 
  - react, react-dom, react-scripts 패키지를 하나하나씩 업그레이드해보면서 react-scripts의 버전 문제 이슈가 있다고함.
  - package.json의 scripts에서 start 명령어에 옵션을 주어 임시방편으로 해결하는 방법으로 해결이 안되는 사례도 있다고 한다.
  - 다음과 같이 환경변수를 설정 하여 `npx react-scripts start` 수행
      ```bash
      # 환경변수 추가

      # 윈도우
      set NODE_OPTIONS=--openssl-legacy-provider
      echo %NODE_OPTIONS%

      # 리눅스
      export NODE_OPTIONS=--openssl-legacy-provider
      echo %NODE_OPTIONS%

      ```
  - 또는 다음과 같이 실행스크립트에 ssl 관련 환경변수를 설정하여 `npm start` 수행
      ```json
      # package.json
      {
        "scripts": {
          "start": "react-scripts --openssl-lagacy-provider start"
        }
      }

      ```




## React 맛보기
### (1) 버튼 추가하기
```js
// src/index.js
import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css';
import App from './App';
import reportWebVitals from './reportWebVitals';

// 익명의 컴포넌트 추가
const MyButton = () => {
  return (
    <button>I'm a button</button>
  );
};


const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <App />
    <MyButton />
  </React.StrictMode>
);

reportWebVitals();

```




### test_MyComponent.tsx
```tsx
import React from 'react';

// 함수형 컴포넌트 예시
const MyComponent: React.FC<PropsType> = ({ prop1, prop2 }) => {
  return (
    <div>
      <h1>Hello, World!</h1>
      <p>prop1: {prop1}</p>
      <p>prop2: {prop2}</p>
    </div>
  );
}

// 클래스형 컴포넌트 예시
class MyComponent extends React.Component<PropsType> {
  render() {
    const { prop1, prop2 } = this.props;
    return (
      <div>
        <h1>Hello, World!</h1>
        <p>prop1: {prop1}</p>
        <p>prop2: {prop2}</p>
      </div>
    );
  }
}

// 컴포넌트에 전달되는 props의 타입을 정의한 예시
type PropsType = {
  prop1: string;
  prop2: number;
}

export default MyComponent;

```

### main.tsx
```tsx
// 다른 파일에서 MyComponent를 import하여 사용하는 예시

// MyComponent.tsx 파일에서 export default로 내보낸 컴포넌트를 import하여 사용
import MyComponent from './MyComponent';

// MyComponent 컴포넌트를 사용하는 예시
const App = () => {
  return (
    <div>
      <MyComponent prop1="Hello" prop2={123} />
    </div>
  );
}

export default App;

```

```tsx
// 동일 파일 내에서 MyComponent를 사용하는 예시

import React from 'react';

const MyComponent: React.FC<PropsType> = ({ prop1, prop2 }) => {
  return (
    <div>
      <h1>Hello, World!</h1>
      <p>prop1: {prop1}</p>
      <p>prop2: {prop2}</p>
    </div>
  );
}

const App = () => {
  return (
    <div>
      <MyComponent prop1="Hello" prop2={123} />
    </div>
  );
}

export default App;

```