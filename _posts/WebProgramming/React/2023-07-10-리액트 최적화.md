---
title:  "리액트 최적화"
excerpt: "리액트 최적화 입니다."

categories:
  - react
tags:
  - [react]

toc: true
toc_sticky: true

last_modified_at: 2023-04-05T20:00:00-05:00
---

## (예제1) 기본적인 useState 업데이트 방식
### 일반적인 업데이트

```js
// 예시
setCount('계산한 새로운 상태');


// 구현
setCount(count + 100);
```

### 함수형 업데이트
```js
// 예시
setCount(blang => {
  // 이전 상태 값을 기반으로 새로운 상태를 계산
  return '계산한 새로운 상태'
});


// 구현
setCount(blang => blang + 100);

```

> 💡둘다 같은 결과를 반환한다.



## (예제2) 기본적인 useState 업데이트 방식 (상세)
### 일반적인 업데이트
```js
import React, { useState } from 'react';

function ExampleComponent() {
  const [count, setCount] = useState(0);

  const handleIncrement = () => {
    setCount(count + 1); // 직접 접근하여 상태를 업데이트
  };

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={handleIncrement}>Increment</button>
    </div>
  );
}

```

> 💡set 으로 직접 접근하고 있다.

### 함수형 업데이트
```js
import React, { useState } from 'react';

function ExampleComponent() {
  const [count, setCount] = useState(0);

  const handleIncrement = () => {
    setCount(prevCount => prevCount + 1); // 콜백 함수를 이용하여 상태를 업데이트
  };

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={handleIncrement}>Increment</button>
    </div>
  );
}

```

> ```js 
> setCount(prevCount => prevCount + 1)
> ```
> 💡setTodos 함수를 호출할 때, 화살표 함수를 사용하여 최신 todos 배열을 인자로 받아와서 새로운 배열을 생성했습니다.  
> 💡setCount 함수를 호출할 때, 콜백 함수를 사용하여 이전의 count 상태를 받아와서 1을 더한 값으로 상태를 업데이트합니다.  




## 함수갱신 최적화
### 요약

렌더링이 발생하면 함수는 계속 갱신된다. 이를 최적화 하는 방법은 다음과 같다.  
> 💡1. 우선 useCallback( 원하는동작, []) 기능으로 함수 갱신을 막는다.  
> 💡2. 이제 함수형 업데이트 통한 접근으로 개별적으로 useState를 핸들링한다.  
> 💡3. 동일한 컴포넌트중에 1개의 수정이 일어나도 각각의 컴포넌트별로 렌더링이 동작 하게된다.  
>  
> <span style="color:blue"><I><b>"`재사용함수` 형태에서 `함수형 업데이트`를 통해 최신갱신된 `useState`를 얻은 뒤 필터링된 새로운 배열로 리턴하는것이 핵심 ! "</b></I></span>


### (비추천) 온리 useCallback 최적화시

```js
const onRemove = useCallback( (id) => {
    setTodos(todos.filter((todo) => todo.id !== id));
}, [todos])


const onToggle = useCallback( (id) => {
    setTodos(todos.map((todo) => 
        todo.id === id ? { ...todo, checked: !todo.checked } : todo,
    ));
}, [todos]);

```
> <span style="color:red"><I><b>설명)</b></I></span>  
> - 목적
>     - useCallback() 함수로 todos 이라는 useState 값이 변경분이 생길때만 함수를 갱신한다. (계속 함수가 갱신되는 것을 방지했다.)
> - 장점
>     - 사용하는 컴포넌트가 많지 않다면 이렇게 사용해도 문제없이 성능이 좋다.  
> - 문제점
>     - 여러개의 동일한 컴포넌트가 존재하는 상태에서 어떤 1개의 컴포넌트가 todos를 수정하면 전체 컴포넌트가 수정되어버린다. (매우 비효율적 렌더링이 발생)



### (추천) useCallback + 함수형업데이트 최적화

```js
    const onRemove = useCallback( (id) => {
        setTodos(todos => (todos.filter((todo) => todo.id !== id)));
    }, []);


    const onToggle = useCallback( (id) => {
        setTodos(todos => ( 

            todos.map((todo) => 
                todo.id === id ? { ...todo, checked: !todo.checked } : todo,

            )
        ));
            
    }, []);

```
> <span style="color:red"><I><b>설명)</b></I></span>  
> - 목적
>     - 우선 useCallback() 함수로 항상 함수를 갱신하지 않고 재사용하도록 했다.
>     - 그리고 setTodos에 콜백 함수를 전달하여 상태를 업데이트한다. (useState함수형 최적화 구현)
> - 장점
>     -  todos 배열을 직접 참조하는 방식이 아니다.
>     - setTodos 콜백 함수를 통해 최신 todos 배열을 인자로 받아온 후, 이 인자를 이용하여 필터링된 새로운 배열을 생성한다.
>     - todos 배열을 직접 참조하지 않고도 업데이트 하므로 더욱 안전.



### 장점
이런 방식으로 업데이트를 진행하면 다음과 같은 장점이 있다.
1. 최신 데이터 사용  
    : 콜백 함수를 통해 항상 최신의 todos 배열을 활용하여 새로운 배열을 생성. 때문에 todos 배열이 업데이트되기 전의 예전 데이터로 업데이트하는 오류를 방지할 수 있다.

2. 의존성 배열의 필요성 제거  
    : useCallback의 의존성 배열을 비워두었기 때문에, todos를 의존성 배열로 추가할 필요가 없다. 따라서, todos가 업데이트되더라도 onRemove 함수가 재생성되지 않아도 된다.

3. 안전한 업데이트(비동기니까!)  
    : setTodos 콜백 함수를 통해 업데이트하므로, 최신 todos 배열을 안전하게 참조할 수 있고, 불필요한 리렌더링을 방지할 수 있다.




