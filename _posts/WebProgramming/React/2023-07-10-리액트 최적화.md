---
title:  "리액트 최적화"
excerpt: "리액트 최적화 입니다."

categories:
  - react
tags:
  - [react]

toc: true
toc_sticky: true

last_modified_at: 2023-04-05T20:00:00-05:00
---

## 불필요한 함수렌더링 최적화(useState함수형 최적화)
### AS-IS

```js
const onRemove = useCallback( (id) => {
    setTodos(todos.filter((todo) => todo.id !== id));
}, [todos])


const onToggle = useCallback( (id) => {
    setTodos(todos.map((todo) => 
        todo.id === id ? { ...todo, checked: !todo.checked } : todo,
    ));
}, [todos]);

```
> <span style="color:red"><I><b>설명)</b></I></span>  
> - 목적
>     - useCallback() 함수로 todos 이라는 useState 값이 변경분이 생길때만 함수를 갱신한다. (계속 함수가 갱신되는 것을 방지했다.)
> - 문제점
>     - 여러개의 컴포넌트가 존재했을때 각각의 컴포넌트중 어떤 1개가 todos 를 
#
## TO-BE

```js
    const onRemove = useCallback( (id) => {
        setTodos(todos => (todos.filter((todo) => todo.id !== id)));
    }, []);


    const onToggle = useCallback( (id) => {
        setTodos(todos => ( 
                            todos.map((todo) => 
                                todo.id === id ? { ...todo, checked: !todo.checked } : todo,
                            )
        ));
            
    }, []);

```
> <span style="color:red"><I><b>설명)</b></I></span>  
> - 목적
>     - useCallback() 함수로 항상 함수를 갱신하지 않고 재사용하도록 했다.
>     - setTodos에 콜백 함수를 전달하여 상태를 업데이트한다.
> - 장점
>     -  todos 배열을 직접 참조하는 방식이 아니다.
>     - setTodos 콜백 함수를 통해 최신 todos 배열을 인자로 받아온 후, 이를 활용하여 새로운 배열을 생성
>     -  todos 배열을 직접 참조하지 않고도 업데이트 하므로 더욱 안전.


### 정리

"매번 this 객체에 직접 접근한다는것이 핵심인듯하다!?"

```js
(todos) => (todos.filter(...))

```

두 번째 코드의 콜백함수에서  를 setTodos에 전달하여 최신 todos 배열을 인자로 받아오고, 이 인자를 이용하여 필터링된 새로운 배열을 생성한다.

> 이런 방식으로 업데이트를 진행하면 다음과 같은 장점이 있다.

1. 최신 데이터 사용  
    : 콜백 함수를 통해 항상 최신의 todos 배열을 활용하여 새로운 배열을 생성합니다. 때문에 todos 배열이 업데이트되기 전의 예전 데이터로 업데이트하는 오류를 방지할 수 있습니다.

2. 의존성 배열의 필요성 제거  
    : useCallback의 의존성 배열을 비워두었기 때문에, todos를 의존성 배열로 추가할 필요가 없다. 따라서, todos가 업데이트되더라도 onRemove 함수가 재생성되지 않아도 된다.

3. 안전한 업데이트  
    : setTodos 콜백 함수를 통해 업데이트하므로, 최신 todos 배열을 안전하게 참조할 수 있고, 불필요한 리렌더링을 방지할 수 있습니다.

  
> 결론적으로, 두 번째 코드는 최신 데이터를 보장하고 더 효율적인 방식으로 상태를 업데이트하는데 도움을 줍니다. 따라서, 가능하다면 두 번째 코드를 활용하는 것이 좋습니다.



## useState 접근 개념
### 기존방식
```js
import React, { useState } from 'react';

function ExampleComponent() {
  const [count, setCount] = useState(0);

  const handleIncrement = () => {
    setCount(count + 1); // 직접 접근하여 상태를 업데이트
  };

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={handleIncrement}>Increment</button>
    </div>
  );
}

```

> set 으로 직접 접근하고 있다.

### 최적화방식 
```js
import React, { useState } from 'react';

function ExampleComponent() {
  const [count, setCount] = useState(0);

  const handleIncrement = () => {
    setCount(prevCount => prevCount + 1); // 콜백 함수를 이용하여 상태를 업데이트
  };

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={handleIncrement}>Increment</button>
    </div>
  );
}

```

>  setTodos 함수를 호출할 때, 화살표 함수를 사용하여 최신 todos 배열을 인자로 받아와서 새로운 배열을 생성했습니다. 
> 
> ```js 
> setCount(prevCount => prevCount + 1)
> ```
> setCount 함수를 호출할 때, 콜백 함수를 사용하여 이전의 count 상태를 받아와서 1을 더한 값으로 상태를 업데이트합니다.  

setTodos 함수를 호출할 때, 화살표 함수를 사용하여  
1. 최신 todos 배열을 인자로 받아와서 새로운 배열을 생성하고 그 결과로 처리한다.
2. 이러한 방식으로 콜백 함수를 사용하여 상태를 업데이트하는 것은 set 접두사를 사용하여 직접 상태를 업데이트하는 것과 유사한 개념이다.
3. 좀 더 안전하고 선호되는 방법이며, React의 성능 최적화를 위해 사용된다.

