---
title:  "노드JS 타입스크립트"
excerpt: "노드JS 타입스크립트 입니다."

categories:
  - nodejs
tags:
  - [node.js]

toc: true
toc_sticky: true

last_modified_at: 2023-03-30T20:00:00-05:00
---

## 타입스크립트 개요
### 타입스크립트를 기본조건
TypeScript (.ts) 파일을 사용하기 위해서는 다음의 기본 조건들이 필요하다.  

1. Node.js와 TypeScript 설치  
    : TypeScript는 Node.js 환경에서 실행되며, 따라서 Node.js와 TypeScript를 설치해야 한다.
  
2. TypeScript 설정 파일(tsconfig.json)  
    : TypeScript 컴파일러는 tsconfig.json이라는 설정 파일을 사용하여 컴파일 옵션을 구성한다. 이 설정 파일은 프로젝트 루트 디렉토리에 위치하며, 필요한 컴파일 옵션들을 지정해야 한다.
  
3. TypeScript 파일 작성  
    : TypeScript는 JavaScript의 슈퍼셋이므로, JavaScript와 동일한 문법을 사용할 수 있다. 더불어 TypeScript의 고급 기능들인 정적 타입 검사, 인터페이스, 데코레이터 등을 활용하여 TypeScript 파일을 작성해야 한다.
  
4. TypeScript 컴파일  
    : 작성한 TypeScript 파일을 JavaScript 파일로 변환하기 위해 TypeScript 컴파일러를 사용해야 한다. tsconfig.json 파일에서 지정한 컴파일 옵션들에 따라 TypeScript 파일을 컴파일하여 JavaScript 파일을 생성할 수 있다.
  
5. JavaScript 실행  
    : 컴파일된 JavaScript 파일을 실행하여 TypeScript의 고급 기능들이 반영된 코드를 실행할 수 있다. JavaScript 파일은 일반적인 방식으로 실행하면 된다. (예를 들어, Node.js 환경에서는 node 명령어를 사용하여 JavaScript 파일을 실행할 수 있다.)
  
위의 기본 조건들을 충족시키면 .ts 파일을 사용할 수 있게 된다.
  
  
### 타입스크립트 Node.js 없이 실행하는 법
일반적으로 Node.js가 TypeScript 파일(.ts)을 실행하기 위해 필요한 컴파일 단계를 수행하게 된다. 그러나 아래 방법으로 Node.js 없이 .ts 파일을 실행 할 수있다. 

- 방법1 (Deno)  
    : Deno(https://deno.land/)는 Node.js와 유사한 JavaScript 및 TypeScript 런타임 환경으로, Node.js와 달리 TypeScript 파일을 직접 실행할 수 있다. Deno는 V8 JavaScript 엔진을 사용하며, 특정 버전의 TypeScript를 내장하고 있어 별도의 컴파일 과정 없이 .ts 파일을 실행할 수 있다.

- 방법2 (ts-node)  
    : ts-node(https://github.com/TypeStrong/ts-node)는 Node.js 환경에서 TypeScript 파일을 실행하기 위한 패키지로, TypeScript 컴파일 단계를 생략하고 직접 .ts 파일을 실행할 수 있다. ts-node를 전역 또는 로컬로 설치한 후에는 명령어를 통해 .ts 파일을 실행할 수 있다.

그러나 이러한 방법들은 Node.js와 비교하여 상대적으로 새로운 기술이라서 주로 쓰진 않는다. 일반적으로 Node.js를 사용하여 .ts 파일을 컴파일하여 실행하는 것이 가장 흔한 방법이다.


## STEP1. TypeScript 설치  
```bash
# 일반적으로 TypeScript를 프로젝트마다 로컬로 설치하는 것이 권장 된다. 
# 이는 프로젝트 내에서 TypeScript의 버전을 관리하고, 
# 프로젝트 별로 다양한 TypeScript 버전을 사용할 수 있는 유연성을 제공하기 위함이다.
npm install typescript 

# package.json
"dependencies": {
    "dotenv": "^16.0.3",
    "express": "^4.18.2",
    "mysql2": "^3.2.0",
    "typescript": "^5.0.4" # 추가되어짐
  }

```

## STEP2. TypeScript 설정 파일(tsconfig.json)
: tsconfig.json 파일을 조정하여 컴파일 옵션을 세밀하게 제어가능하다.
TypeScript 프로젝트를 컴파일할 때, 해당 설정에 따라 TypeScript 컴파일러가 동작한다. 

### tsconfig.json 을 만들지 않은 경우
```json
// 설정 파일이 없을때 디폴트 값을 표현하자면 아래와 같다.
{
  "compilerOptions": {
    "target": "es5",
    "module": "commonjs",
    "strict": true,
    "esModuleInterop": false,
    // 기타 필요한 설정 옵션들
  },
  // 다른 설정 옵션들
}

```

### tsconfig.json 을 작성한 경우
```json
{
  "compilerOptions": {
    "target": "es5",
    "module": "commonjs",  
    "strict": true,
    "esModuleInterop": true,     
    "outDir": "./dist", 
    "sourceMap": true
  },
  "include": [
    "./src/**/*.ts"
  ],
  "exclude": [
    "node_modules"
  ]
}

```

요약
- `"target": "es5"`  
    : 컴파일된 JavaScript의 목표 버전을 지정. 일반적으로 "es5"나 "es6"를 사용.

- `"module": "commonjs"`  
    :  모듈 시스템을 지정. "commonjs"는 Node.js 환경에서 일반적으로 사용되는 CommonJS 스타일의 모듈 시스템을 지정한다. 물론 다른 모듈 시스템 지정도 가능하다.

    ```js
    // "commonjs" 으로 모듈 시스템을 지정

    // 컴파일 명령을 실행하면 example.ts 파일이 example.js 파일로 컴파일되며, 
    // 해당 파일은 Node.js에서 commonjs 모듈시스템 옵션 기반으로 require 함수를 사용하여 로드하고 내보낸 함수를 따위를 사용할 수 있게 된다.

    // 아래는 CommonJS 스타일의 모듈 내보내기 방식을 따릅니다.
    // require() 함수 사용: import 구문 대신 require() 함수를 사용하여 모듈을 불러올 수 있습니다. 이는 CommonJS 스타일의 모듈 로딩 방식을 따릅니다.

    // module.exports 사용: export 구문 대신 module.exports 객체를 사용하여 모듈을 내보낼 수 있습니다. 

    // 모듈 가져오기
    const fs = require('fs');
    const path = require('path');

    // 모듈 내보내기
    function foo() {
    console.log('This is a function from a CommonJS module.');
    }
    module.exports = foo;

    ```
    
    commonjs 옵션을 false로 설정하는 경우는 일반적으로 Node.js 환경이 아닌 브라우저 환경에서 TypeScript 코드를 실행하고자 할 때 사용된다. 브라우저 환경에서는 CommonJS 스타일의 모듈 시스템이 아닌 ES 모듈(ESM) 시스템이 널리 사용되기 때문이다. 예를 들어, 브라우저에서 사용되는 모던 프론트엔드 프레임워크 또는 라이브러리인 React, Vue, Angular 등은 ES 모듈 형태로 제공되며, 이러한 프로젝트에서는 commonjs 옵션을 false로 설정하여 컴파일된 코드가 ES 모듈 형태로 내보내지도록 할 수 있다.

    ```json
    // "es6" 으로 모듈 시스템을 지정
    {
    "compilerOptions": {
        "module": "es6", // 또는 "es2015", "esnext" 등 ES 모듈로 설정
    }
    }

    ```


- `"strict": true` 
    : 엄격한 타입 체크를 활성화. (강력한 타입 검사 기능을 사용하려면 true)

    ```bash
    # "strict" 옵션 TRUE 인 경우
    "strictNullChecks": null과 undefined를 다른 타입과 구분하여 사용할 수 있도록 합니다.
    "strictFunctionTypes": 함수의 매개변수와 반환값의 타입을 엄격하게 체크합니다.
    "strictPropertyInitialization": 클래스의 프로퍼티가 초기화되지 않았을 경우 경고 또는 에러를 발생시킵니다.
    "strictBindCallApply": 함수의 bind, call, apply 메서드의 사용을 제한합니다.
    "strictNullChecks": null과 undefined의 사용을 엄격하게 제한합니다.
    "noImplicitAny": 암묵적으로 any 타입을 사용하는 것을 금지합니다.

    ```

    
- `"esModuleInterop": true"`  
    : ES 모듈과 CommonJS 모듈 간의 상호 운용성을 활성화 개선한다.(대부분의 경우 true 이다.) import 구문으로 CommonJS 모듈을 가져올 수 있고, export default 구문으로 ES 모듈을 내보낼 수 있게된다.

    ```ts 
    /* esModuleInterop 옵션이 true인 경우 */

    // 모듈을 가져올 때 import from 구문 사용 가능
    import * as fs from 'fs';

    // CommonJS 모듈을 가져올 때도 import 구문 사용 가능
    import * as path from 'path';

    // ES 모듈로 내보낼 때 export default 사용 가능
    export default function foo() {
    console.log('This is a default export from an ES module.');
    }

    // CommonJS 모듈로 내보낼 때도 export = 사용 가능
    export = function bar() {
    console.log('This is a CommonJS export from a CommonJS module.');
    };

    ```

    ```ts
    /* esModuleInterop 옵션이 false인 경우 */

    //import fs = require('fs'); // 사용불가(X)
    //const fs = require('fs');  // 사용가능(O)

    // 모듈을 가져올 때는 require()를 사용한 형태의 코드 사용
    import fs = require('fs');

    // CommonJS 모듈을 가져올 때는 require() 함수 사용
    const path = require('path');

    // ES 모듈로 내보낼 때는 export default 사용
    export default function foo() {
    console.log('This is a default export from an ES module.');
    }

    // CommonJS 모듈로 내보낼 때는 module.exports 사용
    module.exports = function bar() {
    console.log('This is a CommonJS export from a CommonJS module.');
    };

    ```

    > ***잠깐!)***  
    > CommonJS 모듈로 내보낼 때는 module.exports를 사용하고, 
    > ES 모듈로 내보낼 때는 export default를 사용한다.

- `"outDir": ./dist"`
    : TypeScript 컴파일된 JavaScript 파일을 지정된 디렉토리에 출력. 
 
- `"sourceMap": true`
    : sourceMap 옵션을 사용하면 소스맵 파일이 함께 생성되어, 디버깅 시에 원본 TypeScript 소스코드와 연결하여 디버깅이 편해진다. 일반적으로 .js.map 확장자를 가지며, 컴파일된 JavaScript 파일과 동일한 디렉토리에 생성된다. 

- `include`
    :  include 옵션이 지정되지 않은 경우, 기본적으로 프로젝트 디렉토리 내의 모든 .ts 및 .tsx 파일이 컴파일 대상으로 간주된다.

    ```json
    {
    // 파일 확장자를 포함한 파일 경로: src/app.ts, src/utils/*.ts
    // 디렉토리 경로: src, src/**/*.ts
    "include": [
      "./src/**/*.ts"
    ],
    }
    
    
    ```

## STEP3. TypeScript 파일 작성  
### .ts
.ts 파일 작성: TypeScript로 작성된 .ts 파일을 작성합니다. TypeScript는 JavaScript의 상위 집합 언어이므로, JavaScript 코드를 TypeScript 파일에 그대로 작성할 수 있습니다. TypeScript는 정적 타입 체크와 ECMA Script의 최신 기능들을 지원하는 등 JavaScript 개발을 보완하는 기능들을 제공합니다.

```ts
// TypeScript는 JavaScript의 상위 집합 언어(슈퍼셋)이므로, JavaScript 코드를 TypeScript 파일에 그대로 작성할 수 있다.

```

## STEP4. TypeScript 컴파일  
```bash
# .ts 파일이 JavaScript 파일로 컴파일되어 생성된다.
tsc <파일이름>.ts

```

## STEP5. JavaScript 실행  
```bash
node <파일이름>.js

```







## 내가 선택한 템플릿엔진 후보

1. EJS 템플릿엔진
    - .ejs 템플릿파일

2. React
    - .jsx 템플릿파일
    - .tsx 템플릿파일

<b>위에 나열한 수많은 템플릿엔진 중 최종 학습 목표는 강세인 React 으로 정했다.</b>