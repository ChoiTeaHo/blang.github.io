---
title:  "노드JS 템플릿엔진(2) 리액트"
excerpt: "노드JS 템플릿엔진(2) 리액트 입니다."

categories:
  - nodejs
tags:
  - [node.js]

toc: true
toc_sticky: true

last_modified_at: 2023-04-02T20:00:00-05:00
---

## 리액트
### 리액트의 강점과 약점
리액트(React)는 인기있는 JavaScript 라이브러리로, 웹 애플리케이션의 사용자 인터페이스(UI)를 구축하기 위해 사용된다.

***강점***  
- 선언적 UI  
    : 리액트는 선언적인 방식으로 UI를 구성할 수 있어, UI의 상태 변화에 따른 업데이트를 효율적으로 처리할 수 있습니다. 이는 코드의 가독성과 유지보수성을 높여줍니다.

- 가상 DOM(Virtual DOM)  
    : 리액트는 가상 DOM을 사용하여 실제 DOM 조작을 최소화하고, 변경된 부분만 업데이트함으로써 UI 업데이트의 성능을 향상시킵니다. 이는 웹 애플리케이션의 빠른 렌더링을 가능하게 합니다.

- 컴포넌트 기반 개발  
    : 리액트는 컴포넌트 기반의 개발을 지원하여, UI를 재사용 가능한 컴포넌트로 구성할 수 있습니다. 이는 코드의 재사용성을 높이고 개발 생산성을 향상시킵니다.

- 큰 생태계  
    : 리액트는 많은 개발자 커뮤니티와 다양한 생태계를 가지고 있어, 다양한 도구와 라이브러리를 활용할 수 있습니다. 또한, 리액트는 Facebook 및 Instagram 등의 대규모 애플리케이션에서 검증된 기술이기도 합니다.
  
***약점***  
- 복잡성  
: 리액트는 처음 사용하는 개발자에게는 학습 곡선이 있을 수 있습니다. 특히, JSX 문법과 컴포넌트 기반의 개발 방식에 익숙하지 않은 경우에는 익숙해지는 데 시간이 걸릴 수 있습니다.

- 단순한 View 라이브러리  
: 리액트는 UI를 관리하는 라이브러리로, 상태 관리, 라우팅, 데이터 통신과 같은 기능은 제공하지 않습니다. 따라서, 별도의 상태 관리 라이브러리나 추가적인 라이브러리를 도입해야 할 수도 있습니다.

- 생태계의 빠른 변화  
: 리액트의 생태계는 빠르게 변화하고 있어, 새로운 버전이 나올 때마다 기존 코드의 업데이트와 호환성


### 리액트에서 사용하는 템플릿파일(.jsx, .tsx)
리액트는 JSX(JavaScript XML)라는 독자적인 템플릿 문법을 가진 템플릿 파일을 사용한다.  
일반적인 템플릿 엔진과는 차이가 있다. 

- JSX 템플릿 파일  
  : 리액트의 기본 템플릿 파일 형식. JavaScript 파일 내에서 XML과 유사한 형태로 컴포넌트의 UI를 작성한다. 이 파일은 일반적으로 ".jsx" 또는 ".js" 확장자를 가진다.  
  JavaScript의 확장 문법으로, JavaScript 코드와 함께 컴포넌트의 UI를 작성하는데 사용된다.

- TSX 템플릿 파일  
  : TypeScript와 JSX를 함께 사용하는 경우에 사용되는 템플릿 파일 형식. TypeScript는 정적 타입 체크와 다양한 기능을 제공하므로, TSX 파일은 TypeScript를 사용하여 작성된 리액트 컴포넌트에서 JSX 문법을 사용할 때 사용한다. 이 파일은 일반적으로 ".tsx" 또는 ".ts" 확장자를 가진다.

요약하면, 위 두 가지 파일 형식이 리액트에서 주로 사용되는 템플릿 파일 종류이다. JSX 파일은 리액트의 기본 템플릿 문법이며, TypeScript를 사용하는 경우에는 TSX 파일을 사용하여 리액트 컴포넌트를 작성할 수 있다.
  

### .tsx 와 .EJS 의 차이
둘은 사용 용도, 문법, 확장자 등이 다르며, 각각의 특징에 따라 다른 상황에서 사용된다고 한다.  
  
요약하면, <span style="color:blue"><b>.tsx 파일</b></span>은 <span style="color:red"><b>클라이언트 측에서 실행되는 React 컴포넌트를 정의하는 파일</b></span>이고, <span style="color:blue"><b>.ejs 파일</b></span>은 <span style="color:red"><b>서버 측에서 실행되는 템플릿 파일로서 서버 사이드 렌더링을 위해 사용</b></span>된다. 

## 리액트 기본 실행 모듈
기본적으로 실행하기 위한 최소한 포함되어야 하는 모듈을 소개한다.

### react 모듈
- react  
    : 리액트의 핵심 모듈로, UI 컴포넌트를 생성하고 관리하는 역할을 수행한다. 가상 DOM(Virtual DOM)을 사용하여 성능을 최적화하고, 컴포넌트의 상태(State)와 속성(Props)을 관리하며, 이벤트 처리, 라이프사이클 메서드 등을 제공한다.

### react-dom 모듈 
- react-dom
    : 리액트에서 실제 DOM(Document Object Model)과 상호작용하기 위한 모듈로, 웹 브라우저에서 리액트 애플리케이션을 렌더링하는 역할을 수행한다. DOM 요소를 조작하고, 컴포넌트를 실제 DOM에 렌더링하며, 이벤트 핸들러를 등록하고 관리하는 등의 기능을 제공한다.

    > react와 react-dom은 함께 사용되어, 리액트 애플리케이션을 개발하고 
    > 브라우저에서 실행시키는데 필수적인 모듈이다.  

### react-scripts 모듈
- react-scripts는 React 애플리케이션을 개발, 빌드 및 실행하기 위한 설정 및 스크립트를 제공하는 패키지 이다. Create React App이라는 React 프로젝트를 쉽게 생성하고 개발 환경을 구성하는 도구에서 사용되는 패키지 이다.

    - <span style="color:green"><b>(1). 개발 서버 (Development Server)</b></span>: react-scripts는 개발용 서버를 제공하여 <span style="color:red"><b>로컬 개발 환경에서 React 애플리케이션을 실행하고 확인</b></span>할 수 있도록 한다. 개발 서버는 코드 변경 시 자동으로 리로드되며, 에러와 경고 메시지를 보여주어 개발 과정을 보다 편리하게 만들어 준다.
        ```bash
        # 개발서버 실행
        cd my-app
        npm start

        ```

    - <span style="color:green"><b>(2). 빌드 스크립트 (Build Scripts)</b></span>: react-scripts는 React 애플리케이션을 배포하기 위한 빌드 스크립트를 제공한다. 이를 통해 애플리케이션 코드를 최적화하고 번들링하여 운영 환경에 배포할 수 있다.
        ```bash
        # 애플리케이션을 배포하기 위해 빌드 스크립트를 실행할 수 있다.
        # 아래 명령어를 통해 애플리케이션을 빌드할 수 있다.
        # 이 명령어는 최적화된 애플리케이션 코드를 생성하고, 배포를 위한 번들 파일들을 생성한다.
        npm run build

        ```

    - <span style="color:green"><b>(3). 웹팩 설정 (Webpack Configuration)</b></span>: react-scripts는 웹팩(Webpack)을 사용하여 React 애플리케이션을 <span style="color:red"><b>번들링하는 설정을 제공</b></span>한다. 웹팩은 모던 자바스크립트, CSS, 이미지 등의 리소스들을 하나의 번들 파일로 묶어서 서버에 제공할 수 있도록 해준다. 웹팩 설정 파일은 일반적으로 프로젝트 루트 디렉토리에 위치하며, 웹팩의 동작 방식, 입력 및 출력 경로, 로더(Loaders)와 플러그인(Plugins) 등을 설정할 수 있다. 요약하면 <span style="color:red"><b>웹팩은 자바스크립트 애플리케이션의 모듈 번들링과 빌드 자동화를 수행하는 모듈 번들러</b></span>이다.

    - <span style="color:green"><b>(4). 개발환경 설정 (Development Environment Configuration)</b></span>: react-scripts는 <span style="color:red"><b>개발 환경을 설정하는 파일들을 제공<b></span>한다. 예를 들어, .env 파일을 통해 환경변수를 설정하거나, .env.local 파일을 통해 로컬 개발 환경에만 적용되는 환경변수를 설정할 수 있다.
        ```bash
        # 이렇게 설정된 환경 변수는 아래와 같이 React 프로젝트에서 접근 가능
        # ex) process.env.REACT_APP_API_URL
        REACT_APP_API_URL=https://api.example.com

        ```

    - (5). react-scripts는 <span style="color:red"><b>Create React App을 통해 생성된 프로젝트에서 기본적으로 사용</b></span>되며, <span style="color:red"><b>React 애플리케이션을 편리하게 개발, 빌드 및 실행</b></span>할 수 있도록 도와준다.
        ```bash
        # Create React App을 통해 프로젝트를 생성하는 것이 가장 일반적인 방법
        # 새로운 React 프로젝트를 생성 가능해짐
        npx create-react-app my-app

        ```

## CASE1. 리액트 수동설치(폐쇄망)
```bash
├── package.json
├── node_modules
├── public
│   ├── index.html  # react 의 기본구조 /public/웰컴파일 필수
└── src
     └── index.js   # react 의 기본구조 /src/리액트트실행파일 필수

```
> <span style="color:blue"><b>npx create-react-app 프로젝트이름</b></span>  
>  
> 위 명령어를 사용하면 Create React App이라는 공식 리액트 프로젝트 템플릿을 이용하여 새로운 리액트 프로젝트를 생성할 수 있다. 이 명령어를 실행하면, 리액트 프로젝트를 위한 초기 파일과 폴더 구조가 생성되며, 필요한 리액트 라이브러리 및 개발 도구가 자동으로 설치된다. 이후 생성된 프로젝트는 개발 서버를 실행하거나 빌드하여 실제 서버에 배포할 수 있다.  
>   
> 하지만 폐쇠망환경은 인터넷이 안되기에 외부에서 셋팅한 모듈을 가지고 리액트 프로젝트를 구축해야한다. <span style="color:red"><b>즉, 위 명령어는 사용할 수 없다.</b></span> 
> <span style="color:red"><b>폐쇠망은 위 명령어 없이 이미 모듈이 구축된 환경을 만든뒤에 start 하는 방법으로 진행해야한다</b></span>.


### (1) NODE 설치
```bash
# package.json 1개의 파일이 생성되어짐.
npm init -y

```


### (2) node_modules 준비
```bash
# 외부에서 리액트 모듈을 포함한 node_modules 디렉토리를 준비.
# npm init 시킨 프로젝트 ROOT 디렉토리에 위치시킨다.
unzip node_modules.zip

```


### (3) 리액트 앱 코드 작성
이제 필요한 디렉토리와 파일을 생성하고, 리액트 앱의 코드를 작성한다. 예를 들어, src 디렉토리를 생성하고 그 안에 index.js 파일을 작성하여 리액트 앱의 진입점(엔트리 포인트)을 설정한다.

```bash
mkdir /src
touch /src/index.js  # Entry Point [React APP] 파일작성

```

```js
// src/index.js
import React from 'react';
import ReactDOM from 'react-dom';

const App = () => {
  return (
    <div>
      <h1>Hello, React!</h1>
    </div>
  );
};

ReactDOM.render(<App />, document.getElementById('root'));

```

### (3) (개발)실행 스크립트 생성 및 실행
react-scripts 모듈 명령을 사용하여 실행스크립트를 명명하고, 개발 서버를 실행한다.
```bash
# package.json
{
  "scripts": {
    "start": "react-scripts start"
  }
}

```
```bash
# 일반적인 리액트 개발서버 실행(react-scripts 모듈의 기능)
npx react-scripts start

# 실행 스크립트 생성으로 개발서버 실행
npm start

```

폐쇄망 환경에서 절차적으로 스타트 해본결과 발생한 이슈를 정리하면 다음과 같다.
1. 파일 관련 에러가 발생
    ```bash
    # 에러내용
    # 루트/piblic/index.html 파일이 존재해야한다. (기본 웰컴 파일이 있어야 하나보다.) 
    npx react-scripts start
     Could not find a required file.
      Name: index.html
      Searched in: C\Users\MT01301\Desktop\react-study\public

    # (/piblic/index.html 추가 후 해결)

    # 루트/src/index.js 파일이 존재해야한다. (기본 실행파일이 있어야 하나 보다.)
    npx react-scripts start
     Could not find a required file.
      Name: index.js
      Searched in: C\Users\MT01301\Desktop\react-study\src
      
     # (/src/index.js 추가 후 해결)

    ```

2. 프록시 관련 에러가 발생
    
    ```json
    // package.json
    // 환경에 맞는 [프록시]디펜던시 추가
    {
      "dependencies": {
        "proxy": "http://stg.kbfg.in"  //prod
        //"proxy": "http://dev.kbfg.in"  //local, dev
      }
    }

    ```
    > <b>***이렇게 하니 폐쇄망 환경에서 정상적으로 리액트가 구동되었다.***</b>

3. 시작시 Error: error:0308010C:digital envelope routines::unsupported
    - react, react-dom, react-scripts 패키지를 하나하나씩 업그레이드해보면서 react-scripts의 버전 문제 이슈가 있다고함.
    - package.json의 scripts에서 start 명령어에 옵션을 주어 임시방편으로 해결하는 방법으로 해결이 안되는 사례도 있다고 한다.
    - 다음과 같이 환경변수를 설정 하여 `npx react-scripts start` 수행
        ```bash
        # 환경변수 추가

        # 윈도우
        set NODE_OPTIONS=--openssl-legacy-provider
        echo %NODE_OPTIONS%

        # 리눅스
        export NODE_OPTIONS=--openssl-legacy-provider
        echo %NODE_OPTIONS%

        ```
    - 또는 다음과 같이 실행스크립트에 ssl 관련 환경변수를 설정하여 `npm start` 수행
        ```json
        # package.json
        {
          "scripts": {
            "start": "react-scripts --openssl-lagacy-provider start"
          }
        }

        ```

### 완료
개발 서버가 성공적으로 실행되면, 브라우저에서 http://localhost:3000에 접속하여 리액트 앱을 확인할 수 있다. <span style="color:red"><b>이렇게 수동으로 리액트 프로젝트를 설치하고 실행 가능</b></span>하다. <span style="color:red"><b>그러나 npx create-react-app 명령어를 사용하는 것이 더 간편하고 권장되는 방법</b></span>이다.


## React 맛보기
### test_MyComponent.tsx
```tsx
import React from 'react';

// 함수형 컴포넌트 예시
const MyComponent: React.FC<PropsType> = ({ prop1, prop2 }) => {
  return (
    <div>
      <h1>Hello, World!</h1>
      <p>prop1: {prop1}</p>
      <p>prop2: {prop2}</p>
    </div>
  );
}

// 클래스형 컴포넌트 예시
class MyComponent extends React.Component<PropsType> {
  render() {
    const { prop1, prop2 } = this.props;
    return (
      <div>
        <h1>Hello, World!</h1>
        <p>prop1: {prop1}</p>
        <p>prop2: {prop2}</p>
      </div>
    );
  }
}

// 컴포넌트에 전달되는 props의 타입을 정의한 예시
type PropsType = {
  prop1: string;
  prop2: number;
}

export default MyComponent;

```

### main.tsx
```tsx
// 다른 파일에서 MyComponent를 import하여 사용하는 예시

// MyComponent.tsx 파일에서 export default로 내보낸 컴포넌트를 import하여 사용
import MyComponent from './MyComponent';

// MyComponent 컴포넌트를 사용하는 예시
const App = () => {
  return (
    <div>
      <MyComponent prop1="Hello" prop2={123} />
    </div>
  );
}

export default App;

```

```tsx
// 동일 파일 내에서 MyComponent를 사용하는 예시

import React from 'react';

const MyComponent: React.FC<PropsType> = ({ prop1, prop2 }) => {
  return (
    <div>
      <h1>Hello, World!</h1>
      <p>prop1: {prop1}</p>
      <p>prop2: {prop2}</p>
    </div>
  );
}

const App = () => {
  return (
    <div>
      <MyComponent prop1="Hello" prop2={123} />
    </div>
  );
}

export default App;

```