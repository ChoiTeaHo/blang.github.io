---
title:  "스프링 프로젝트 메이븐없이 만들기"
excerpt: "스프링 프로젝트 메이븐없이 만들기"

categories:
  - spring
tags:
  - [spring, 프레임워크]

toc: true
toc_sticky: true

last_modified_at: 2022-10-12T20:14:00-14:00
---

## 개요
: 스프링 프로젝트의 기본 생성 방법보다 아주 원초적으로 스프링 프로젝트가 필요한 최소요구조건이 무엇인지 알아야 한다. 이를 학습하기 위해 작성한다.

- 프로젝트: `Dynamic Web Project` 
- 템플릿: `Dynamic Web Project`

## 상세 
> [https://developer-syubrofo.tistory.com/m/14]https://developer-syubrofo.tistory.com/m/14

## 요약
: 위 참고블로그에서 직접 테스트도 해본 요약이다.

### (1) Dynamic Web Project 생성
: 프로젝트를 생성한다.

### (2) 스프링 라이브러리 준비
: 스프링을 구동하기 위한 라이브러리를 준비한다.

```
- aspectjrt-1.6.10.jar
- javax.imject-1.jar
- jcl-over-slf4j-1.6.6.jar
- jsp-api-2.1.jar
- jstl-1.2.jar
- junit-4.7.jar
- log4j-1.2.15.jar
- servlet-api-2.5.jar
- slf4j-api-1.6.6.jar
- slf4j-log4j12-1.6.6.jar
- spring-aop-4.3.9.RELEASE.jar
- spring-beans-4.3.9.RELEASE.jar
- spring-context-4.3.9.RELEASE.jar
- spring-core-4.3.9.RELEASE.jar
- spring-expression-4.3.9.RELEASE.jar
- spring-web-4.3.9.RELEASE.jar
- spring-webmvc-4.3.9.RELEASE.jar

```

### (3) Spring Bean Configuration File 생성
/WebContent/WEB-INF/name-servlet.xml  
  
( ***통상 spring-servlet.xml 를 이름을 부여함.*** )
{: .notice--info}

- namespace 탭에서 bean, context 딱 2가지를 체크하기.
- 그리고 파일내용 작성

    ```xml
    <?web version="1.0" encoding="UTF-8"?>
    <beans xmlns="http://www.springframework.org/schema/beans"
        xlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xmlns:context="http://www.springframework.org/schema/context" 
        xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
    
    <bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">
        <property name="prefix" value="/WEB-INF/spring/" />
        <property name="suffix" value=".jsp" />

    <context:annotation-config/>
    
    <bean class="spring.home.controller.HomeController"/>

    ```

### (4) web.xml 생성

/WebContent/WEB-INF/web.xml
{: .notice--info}

```xml
<?web version="1.0" encoding="UTF-8"?>
<web-app version="2.5" xmlns:web=http://xmlns.jcp.org/xml/ns/javaee">
    <!--  서블릿1  -->
    <servlet>
        <servlet-name>spring</servlet-name>
        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
    </servlet>
    <servlet-mapping>
        <servlet-name>spring</servlet-name>
        <url-pattern>*.do</url-pattern>
    </servlet-mapping>

    <!--  가장먼저 보여질 첫페이지를 설정해준다. 여기서는 WEB-INF 안에 접근가능하다. -->
    <welcome-file-list>
        <welcome-file>homd.do</welcome-file>
    </welcome-file-list>
</web-app>

```

### (5) 컨트롤러 작성

/src/spring.home.controller/HomeController.java
{: .notice--info}

- src 우클릭 - spring.home.controller 패키지생성
- HomeController.java 작성
  
    ```java
     @Controller
     public class HomeController {
     
     @RequestMapping(value="/home.do")
     public ModelAndView home() {
         Systme.out.pirnt("ModelAndView start >>>> ");
         return new ModelAndView("home")
     
     }
        
    ```


## MVC 처리 (요약)
![사진1](/assets/images/WebProgramming/Spring/spring_process01.jpg)

### (1) 톰캣 서버 실행
1. WAS가 구동되면 web.xml를 로딩한다.
2. 로딩된 web.xml에서 ContextLoaderListener 클래스를 생성한다.
3. 생성된 ContextLoaderListener는 root-context.xml을 로딩한다. 이때 root-context는 Context-param으로 선언되었기 때문에 WebApp 전역적으로 사용된다.
4. 로딩된 root-context에 등록된 Spring 컨테이너가 구동되며 Service, dao 등의 객체도 함께 생성된다.

### (2) 클라이언트로부터 요청이 왔을 때
5. DispatcherServlet이 구동된다. 이때 Servlet으로 선언되었기 때문에 해당 Servlet 내에서만 사용가능한 Context가 된다.
6. DispatcherServlet이 servlet-context.xml을 로딩한다.
7. 로딩된 servlet-context에 등록된 Spring 컨테이너가 구동되며 등록된 Controller 객체를 생성한다.

### (3) 클라이언트 요청 처리
8. 요청 URL을 DispatcherServlet이 가로챈다.
9. HandlerMapping 객체가 알맞은 Controller 객체를 찾은 후 DispatcherServlet에게 전달한다.
10. DispatcherServlet은 Controller 종류에 따라 똑같은 방식으로 처리하도록 만들어졌고 이를 가능하게 하는 것이 HandlerAdapter이다. HandlerAdapter는 HandlerMapping이 찾은 컨트롤러의 적절한 메서드를 실행시킨 후 결과를 ModelAndView 객체로 변환해 DispatcherServlet에게 전달한다.
11. DispatcherServlet이 ModelAndView 객체를 받으면 ViewResolver 객체가 화면에 표시할 뷰 객체를 찾아 DispatcherServlet에 리턴한다.
12. DispatcherServlet에 뷰 객체가 리턴되면 뷰 객체에 응답 결과 생성을 요청한 후 화면에 나타낸다.


## MVC 처리 (상세)
### (1) 톰캣 서버 실행
1. 웹어플리케이션이 실행되면 Tomcat(WAS) 에 의해 web.xml 파일이 로딩된다.
  - load-on-startup 으로 톰캣시작시 servlet 생성가능하도록 설정 가능함.

2. web.xml이 등록되어있는 ContextLoaderListener(JAVA class)가 생성된다.
  - ContextLoaderListener 클래스는 ServletContextListener 인터페이스를 구현하고 있다.
  - 이 인터페이스는  최상위 컨텍스트인 ApplicationContext를 생성하는 역할을 수행한다.
  - 즉, ContextLoaderListener는 ApplicationContext를 생성한다.

3. 생성된 ContextLoaderListener는 ApplicationContext.xml을 로딩한다. (최상위컨텍스트)
  - 첫번째 Spring Container 이다.
  - root-context.xml 을 말한다.
    - root-context 또는 application-context는 view와 관련되지 않은 객체를 정의한다.
    - 그러니까 결국은 Service, Repository 등 비지니스 로직 관련 bean을 설정하면 될것 같다.
    - root-context에 등록되는 빈들은 모든 컨텍스트에서 사용 할 수 있다. (공유가능)
    - Service, DAO를 포함한 웹환경에서 독립적인 Bean들을 담아둔다. (@Service, @Repository)
    - 서로 다른 servlet-context에서 공유해야 하는 빈들을 등록해놓고 사용할 수 있다.
    - servlet-context내 Bean들은 이용이 불가능하다.
	
4. ApplicationContext.xml (root-context.xml) 에 등록되어있는 설정에 따라 Spring Container가 구동된다.
- 이때 개발자가 작성한 비즈니스 로직에 대한 부분과 DAO, VO 객체들이 생성된다.
	
5. 웹어플리케이션 LOAD 완료
- 클라이언트로부터 웹어플리케이션 요청을 대기한다.


### (2) 클라이언트로부터 요청이 왔을 때
1. 사용자 요청이 오면 wab.xml 으로 먼저 전달된다.
2. web.xml에 등록되어있는 DispatcherServlet (서블릿)이 생성된다.
  - DispatcherServlet은 FrontController의 역할을 수행한다.
  - 클라이언트로부터 요청은 메세지를 분석하여 알맞은 PageController에게 전달하고 PageController에게서 응답을 받아 요청에 따른 응답을 어떻게 할지 정한다.
  - 이러한 클래스들을 HandlerMapping, ViewResolver 클래스라고 한다.

3. 생성된 DispatcherServlet는 spring-mvc.xml(서블릿)을 로딩한다.
  - 두번째 Spring Container 이다.
  - servlet-context.xml 을 말한다.

4. 두번째 Spring Container가 (servlet-context.xml) 구동되면 응답에 맞는 PageController 들이 동작한다.
  - 이때 첫번째 Spring Container (root-context.xml)가 구동되면서 생성된 DAO, VO, ServiceImpl 클래스들과 협업하여 알맞은 작업을 처리하게된다.
  - HandlerMapping의 역할을 수행한다. 즉, url 패턴에 맞는 컨트롤러를 찾는다. 맞는 컨트롤러를 찾으면 view파일 이름을 return 한다.
  - ViewResolver 역할을 수행한다. 받아온 view파일 이름은 다시 두번째 Container(servlet-context.xml) 으로 돌아와서 프로젝트를 생성할때 만들어진 prefix와 suffix로 view파일 경로를 만들어준다.
  - 이렇게 만들어진 view파일을 가지고 jsp파일이 실행되면서 클라이언트에게 보여지게 된다.

