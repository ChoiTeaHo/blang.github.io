---
title:  "스프링 에러처리(1)"
excerpt: "스프링 에러처리(1) 입니다."

categories:
  - spring
tags:
  - [spring, 프레임워크]

toc: true
toc_sticky: true

last_modified_at: 2024-07-12T13:17:00-17:00:00
---


## 개요
> ❗<span style='color:green'>***WAS내의 마이바티스로 운영되는 DB1 DB2 트랜잭션이 작동하지 않는다.***</span>  
> 💡 1.<span style='color:blue'>**서로의 세션이 다르기 때문임을 확인 함.**</span>  



## 구현
### GlobalExceptionHandler.java : Exception 전역 처리
```java
/*
	 * 1. 모든 컨트롤러에서 발생하는 (@ControllerAdvice 으로 인해. 컴포넌트스캔과 함께 사용되므로 Bean주입이 되어있음.) 
	 * 2. 익셉션들을 @ExceptionHandler(클래스명) 으로 필터링되어 선행처리 된다.
*/
@ControllerAdvice
@Slf4j
public class GlobalExceptionHandler {

	/** javax.validation.Valid or @Validated 으로 binding error 발생시 발생한다. **/
    @ExceptionHandler(MethodArgumentNotValidException.class)
    protected ResponseEntity<ErrorResponse> handleMethodArgumentNotValidException(MethodArgumentNotValidException e) {
        log.error("handleMethodArgumentNotValidException", e);
        final ErrorResponse response = ErrorResponse.of(ErrorCode.INVALID_INPUT_VALUE, e.getBindingResult());
        return new ResponseEntity<>(response, HttpStatus.BAD_REQUEST);
    }
    /** @ModelAttribut 으로 binding error 발생시 BindException 발생한다. **/
    @ExceptionHandler(BindException.class)
    protected ResponseEntity<ErrorResponse> handleBindException(BindException e) {
        final ErrorResponse response = ErrorResponse.of(ErrorCode.INVALID_INPUT_VALUE, e.getBindingResult());
        return new ResponseEntity<>(response, HttpStatus.BAD_REQUEST);
    }
	/** enum type 일치하지 않아 binding 못할 경우 발생 **/
    @ExceptionHandler(MethodArgumentTypeMismatchException.class)
    protected ResponseEntity<ErrorResponse> handleMethodArgumentTypeMismatchException(MethodArgumentTypeMismatchException e) {
        log.error("handleMethodArgumentTypeMismatchException", e);
        final ErrorResponse response = ErrorResponse.of(e);
        return new ResponseEntity<>(response, HttpStatus.BAD_REQUEST);
    }
	/** 지원하지 않은 HTTP method 호출 할 경우 발생 **/
    @ExceptionHandler(HttpRequestMethodNotSupportedException.class)
    protected ResponseEntity<ErrorResponse> handleHttpRequestMethodNotSupportedException(HttpRequestMethodNotSupportedException e) {
        log.error("handleHttpRequestMethodNotSupportedException", e);
        final ErrorResponse response = ErrorResponse.of(ErrorCode.METHOD_NOT_ALLOWED);
        return new ResponseEntity<>(response, HttpStatus.METHOD_NOT_ALLOWED);
    }

	/** Authentication 객체가 필요한 권한을 보유하지 않은 경우 발생합 **/
    @ExceptionHandler(AccessDeniedException.class)
    protected ResponseEntity<ErrorResponse> handleAccessDeniedException(AccessDeniedException e) {
        log.error("handleAccessDeniedException", e);
        final ErrorResponse response = ErrorResponse.of(ErrorCode.HANDLE_ACCESS_DENIED);
        return new ResponseEntity<>(response, HttpStatus.valueOf(ErrorCode.HANDLE_ACCESS_DENIED.getStatus()));
    }

    /** [커스텀익셉션] BusinessException에서 발생한 에러 **/
    @ExceptionHandler(BusinessExceptionHandler.class)
    protected ResponseEntity<ErrorResponse> handleCustomException(final BusinessExceptionHandler e) {
        final ErrorCode errorCode = e.getErrorCode();
        final ErrorResponse response = ErrorResponse.of(errorCode); //ex)ENTITY_NOT_FOUND
        return new ResponseEntity<>(response, HttpStatus.valueOf(errorCode.getStatus()));
    }

    /** [그외 전체 Exception] 모든 Exception 경우 발생 **/
    @ExceptionHandler(Exception.class)
    protected ResponseEntity<ErrorResponse> handleException(Exception ex) {
        //final ErrorResponse response = ErrorResponse.of(ErrorCode.INTERNAL_SERVER_ERROR);
        final ErrorResponse response = ErrorResponse.of(ErrorCode.INTERNAL_SERVER_ERROR, ex.getMessage());
        return new ResponseEntity<>(response, HttpStatus.INTERNAL_SERVER_ERROR);
    }
    
}

```
  
> ❗<span style='color:green'>***Exception 전역처리***</span>  
> 💡 <span style='color:blue'>1.**모든 컨트롤러에서 발생하는 (@ControllerAdvice 으로 인해. 컴포넌트스캔과 함께 사용되므로 Bean주입이 되어있음.)**</span>  
> 💡 <span style='color:blue'>2.**익셉션들을 @ExceptionHandler(클래스명) 으로 필터링되어 선행처리 된다.**</span>  
>   
> ❗<span style='color:green'>***Exception Wrapping 처리하여 응답***</span>  
> 💡 <span style='color:blue'>**직접만든 ErrorResponse 클래스를 생성하여 json포맷으로 wrapping 한다**</span>  
> 💡 <span style='color:blue'>**공통 규약된 에러메세지를 전달 할 수 있다.**</span>  
  
1.일부의 Exception 을 감지하도록 처리하고있다.  
2.커스텀한 handleCustomException 감지하도록 추가해주었다.   
3.그외 전체 Exception.class 자체를 잡아서 감지하도록 추가해주었다.  
{: .notice--info}

 
### ErrorResponse.java : Exception 동일한 포맷처리(Wrapping)
```java
/**
 * Error Response
 * 간혹 Map<Key, Value> 형식으로 처리하는데 이는 좋지 않다. 
 * 우선 Map 이라는 친구는 런타입시에 정확한 형태를 갖추기 때문에 객체를 처리하는 개발자들도 정확히 무슨 키에 무슨 데이터가 있는지 확인하기 어렵다.
 * 리턴 타입이 ResponseEntity<ErrorResponse> 으로 무슨 데이터가 어떻게 있는지 명확하게 추론하기 쉽도록 구성하는 게 바람직하다.
 * 
 * 이 클래스의 내용을 POJO 객체로 관리하면 errorResponse.getXXX(); 이렇게 명확하게 객체에 있는 값을 가져올 수 있다. 
 * 그 밖에 특정 Exception에 대해서 ErrorResponse 객체를 어떻게 만들 것인가에 대한 책임을 명확하게 갖는 구조로 설계할 있다.
 */
/**
 * Global Exception Handler에서 발생한 에러에 대한 응답 처리를 관리
 */
@Getter
@NoArgsConstructor(access = AccessLevel.PROTECTED)
public class ErrorResponse {

	private int status;                // 에러 상태 코드
	private String code;			   // 에러 구분 코드
    private String message;            // 에러 메시지
    private List<FieldError> errors;   // 상세 에러 메시지
    private String reason;             // 에러 이유 (추가)


    
    /**********************************************************************************************
     * 생성자
     **********************************************************************************************/
    /* ErrorResponse 생성자-1*/
    private ErrorResponse(final ErrorCode code) {
        this.message = code.getMessage();
        this.status = code.getStatus();
        this.code = code.getCode();
        this.errors = new ArrayList<>();
    }
    
    /* ErrorResponse 생성자-2 */
    protected ErrorResponse(final ErrorCode code, final String reason) {
        this.message = code.getMessage();
        this.status = code.getStatus();
        this.code = code.getCode();
        this.reason = reason;
    }
    
    /* ErrorResponse 생성자-3 */
    private ErrorResponse(final ErrorCode code, final List<FieldError> errors) {
        this.message = code.getMessage();
        this.status = code.getStatus();
        this.errors = errors;
        this.code = code.getCode();
    }

    /**********************************************************************************************
     * Global Exception 전송 타입
     **********************************************************************************************/
    /* Global Exception 전송 타입-1 */
    public static ErrorResponse of(final ErrorCode code, final BindingResult bindingResult) {
        return new ErrorResponse(code, FieldError.of(bindingResult));
    }

    /* Global Exception 전송 타입-2 */
    public static ErrorResponse of(final ErrorCode code) {
        return new ErrorResponse(code);
    }

    // ? 
    public static ErrorResponse of(final ErrorCode code, final List<FieldError> errors) {
        return new ErrorResponse(code, errors);
    }

    /* Global Exception 전송 타입-3 */
    public static ErrorResponse of(final ErrorCode code, final String reason) {
        return new ErrorResponse(code, reason);
    }

	/** Global Exception 전송 타입-4 (enum type 일치하지 않아 binding 못할 경우 발생) **/
    public static ErrorResponse of(MethodArgumentTypeMismatchException e) {
        final String value = e.getValue() == null ? "" : e.getValue().toString();
        final List<ErrorResponse.FieldError> errors = ErrorResponse.FieldError.of(e.getName(), value, e.getErrorCode());
        return new ErrorResponse(ErrorCode.INVALID_TYPE_VALUE, errors);
    }
    
    /**********************************************************************************************
     * POJO
	 * 에러를 e.getBindingResult() 형태로 전달 받는 경우 해당 내용을 상세 내용으로 변경하는 기능을 수행한다.
	 * 이 클래스의 내용을 POJO 객체로 관리하면 errorResponse.getXXX(); 이렇게 명확하게 객체에 있는 값을 가져올 수 있다. 
     **********************************************************************************************/
    @Getter
    @NoArgsConstructor(access = AccessLevel.PROTECTED)// 생성자를 통해서 값 변경 목적으로 접근하는 메시지들 차단 어노테이션
    public static class FieldError {
        private String field;
        private String value;
        private String reason;

        private FieldError(final String field, final String value, final String reason) {
            this.field = field;
            this.value = value;
            this.reason = reason;
        }

        public static List<FieldError> of(final String field, final String value, final String reason) {
            List<FieldError> fieldErrors = new ArrayList<>();
            fieldErrors.add(new FieldError(field, value, reason));
            return fieldErrors;
        }

		/**
		 * 아래 코드와 동일한 효과
		 * 
		 * List<FieldError> fieldErrorList = Arrays.asList(
   		 * new FieldError("username", "", "Username cannot be empty"),
    	 * new FieldError("age", "-1", "Age must be positive")
		 * );
		 */
        private static List<FieldError> of(final BindingResult bindingResult) {
            final List<org.springframework.validation.FieldError> fieldErrors = bindingResult.getFieldErrors();
            return fieldErrors.stream()
                    .map(error -> new FieldError(
                            error.getField(),
                            error.getRejectedValue() == null ? "" : error.getRejectedValue().toString(),
                            error.getDefaultMessage()))
                    .collect(Collectors.toList());
        }
    }
}

```

> ❗<span style='color:green'>***Exception Wrapping 처리***</span>  
> 💡 <span style='color:blue'>1.**생성자를 만들고**</span>  
> 💡 <span style='color:blue'>2.**ErrorResponse객체를 생성하는 목적의 여러 메소드를 만든다. (메소드는 생성자를 호출하여 초기화)**</span>  
> 💡 <span style='color:blue'>3.**그 중 BindingResult 형태로 메소드가 호출되면 POJO의 FieldError 기능으로 조립하여 상세한 내용을 리턴한다.**</span>  
>   
> ❗<span style='color:green'>***BindingResult는 뭘까***</span>  
> ![사진1](/assets/images/WebProgramming/Spring/spring-error-bindingresult.png)  
> 💡 <span style='color:blue'>1.**예를들어 @Valid 의 경우에는 MethodArgumentNotValidException 을 발생시킨다.**</span>  
> 💡 <span style='color:blue'>2.**MethodArgumentNotValidException 에는 여러 값들이 있으며, 그 중 BindingResult 라는 객체에 예외에 대한 좀 더 자세하고 많은 정보들이 담겨있다.**</span>  
> 💡 <span style='color:blue'>3.**BindingResult 객체 안에서 error 와 관련된 필요한 값을 가져오기 위해 BindingResult.getFieldErrors() 메소드를 이용하여 BindingResult 가 갖고 있는 errors 를 FieldError 라는 객체 형태로 반환받고**</span>  
> 💡 <span style='color:blue'>4.**FieldError 객체에서 필요한 값들을 사용자(개발자) 가 정의한 예외 객체에 매핑하여 사용한다.**</span>  
>   - Field : 객체에서 예외가 발생한 field
>   - RejectedValue : 어떤 값으로 인해 예외가 발생하였는지
>   - DefaultMessage : 해당 예외가 발생했을 때 제공할 message 는 무엇인지
>         
  
1. 핵심은 ErrorCode라는 Enum을 받아서 해당 class를 생성하도록 구현한다.  
2. Enum을 통해서 한눈에 볼 수 있으며 리턴된 내용의 형식이 일치한다.  
3. BindingResult 형태는 e.getBindingResult() 형태로 들어오는 경우이다. 이는 Spring Framework에서 form 태그 검증 결과를 담고 있는 객체이다.  
{: .notice--info}
