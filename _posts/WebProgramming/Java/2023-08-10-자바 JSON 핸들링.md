---
title:  "자바 JSON 핸들링"
excerpt: "자바 JSON 핸들링 입니다."

categories:
  - java
tags:
  - [java]

toc: true
toc_sticky: true

last_modified_at: 2023-08-10T09:00:00-18:00:00
---

## 기본적인 JSON 구조
> ❗***JSON의 일반적인 구조***  
> 💡 "키": "값" 쌍으로 이루어진 객체(object)의 집합  
> 💡 "키"는 해당하는 "값"에 매핑  
> 💡 객체는 중괄호 {}로 둘러싸여 있음.  
> 💡 여러 객체를 배열로 묶을 수도 있음.  


## depth1(객체): 키: 값
```json
// 기본
{
  "status":200,   // 이거 꺼내보자
  "msg":"성공",    // 이거 꺼내보자
}

```


### 핸들링 (org.json.simple 패키지)
```java
import org.json.simple.parser.JSONParser;
import org.json.simple.JSONObject;
//import org.json.simple.JSONArray;

String strJsonStr = "[제이슨 형태 데이터]";

// [org.json.simple 패키지]
JSONParser parser = new JSON parser();
JSONObject jsonObject = (JSONObject) parser.parse(strJsonStr);

// 단순 객체 JSON 꺼내기
long lStatus = (long) jsonObject.get("status");
String strStatus = (String) jsonObject.get("status").toString();
String strMsg = (String) jsonObject.get("msg");

``` 


### 핸들링 (org.json 패키지)
```java
import org.json.JSONObject;

String strJsonStr = "[제이슨 형태 데이터]";

// [org.json 패키지]
JSONObject jsonObject = new JSONObject(strJsonStr);

// 단순 객체 JSON 꺼내기
int iStatus = jsonObject.getInt("status");
String strStatus = Integer.toString(iStatus);
String strMsg = jsonObject.getString("msg");

```

## 정리
> ❗***설명***  
> 💡 단순한 1depth 형태이다.  
> 💡 기본적인 사용법이다.  



## depth1(배열객체) 키: [값1,값2,값3]
### JSON 형태
```json
// 키의 값이 배열[] 형태이다.
{
  "status":200,
  "msg":"성공",
  "result": [   // 이거 꺼내보자
    "data1",
    "data2",
  ],
}

```
### 핸들링 (org.json.simple 패키지)
```java
import org.json.simple.parser.JSONParser;
import org.json.simple.JSONObject;
import org.json.simple.JSONArray;

String strJsonStr = "[제이슨 형태 데이터]";

// [org.json.simple 패키지]
JSONParser parser = new JSON parser();
JSONObject jsonObject = (JSONObject) parser.parse(strJsonStr);


// 단순배열 JSON 객체 꺼내기
JSONArray jsonArray = jsonObject.get("result");


// 방법1 (기본 for문)
for(int i=0; i<jsonArray.size(); i++) {
  String strValue = (String) jsonArray.getString(i);
}

// 방법2 (향상된 for문)
for(String value: jsonArray) {
  String strValue = (String) value;
}

//방법3 (toList로 객체를 List 으로 변경)
// 이 패키지는 해당 메소드 없음.

``` 


### 핸들링 (org.json 패키지)
```java
import org.json.JSONObject;
import org.json.JSONArray;

String strJsonStr = "[제이슨 형태 데이터]";

// [org.json 패키지]
JSONObject jsonObject = new JSONObject(strJsonStr);


// 단순배열 JSON 객체 꺼내기
JSONArray jsonArray = jsonObject.getJSONArray("result");

// 방법1 (기본 for문)
for(int i=0; i<jsonArray.length(); i++) {
  String strValue = jsonArray.getString(i);
}

// 방법2 (향상된 for문)
for(String value: jsonArray) {
  String strValue = value;
}

//방법3 (toList로 객체를 List 으로 변경)
String[] strArr = jsonArray.toList().toArray(new String[0]);

for(String value: strArr) {
  String strValue = value;
}


```

### 정리
> ❗***설명***  
> 💡 단순한 1depth 형태로 이루어진 배열이다.  
> 💡 기본적인 사용법이다.  
> - 각 패키지 모두 JSONArray 객체를 활용하는것을 알 수 있다.




## depth2(배열안에 객체): 키: [ {키:값}, {키:값} ]
### JSON 형태
```json
{
  "status":200,
  "msg":"성공",
  "result": [
    "data1",
    "data2",
  ],
  "address": [   // 이거 꺼내보자
    {
      "data1" :"데이터1의 값 홍길동",
      "data2" :"데이터2의 값 홍길동주소"
    }, 
    {
      "data1" :"데이터1의 값 박명수",
      "data2" :"데이터2의 값 박명수주소"
    }, 
  ]
}

```

> ❗***잠깐)***  
> 💡 address 객체가 추가되었다.  
> 💡 키값은 배열인데, 배열 안에 또 객체가 들어있다.  
> 💡 평소 자주 보던 구조로, 언제나 복잡해보이는 형태다.  



### 핸들링 (org.json.simple 패키지)
```java
import org.json.simple.parser.JSONParser;
import org.json.simple.JSONObject;
import org.json.simple.JSONArray;

String strJsonStr = "[제이슨 형태 데이터]";

// [org.json.simple 패키지]
JSONParser parser = new JSONParser();
JSONObject jsonObject = (JSONObject) parser.parse(strJsonStr);


// 객체로 이루어진 배열 JSON 꺼내기
JSONArray jsonArray = (JSONArray) jsonObject.get("address");

for(Object item : jsonArray) {

  JSONObject objAddress = (JSONObject) item;

  String data1 = (String) objAddress.get("data1").toString(); //키: data1
  String data2 = (String) objAddress.get("data2").toString(); //키: data2

}

``` 


### 핸들링 (org.json 패키지)
```java
import org.json.JSONObject;
import org.json.JSONArray;

String strJsonStr = [제이슨데이터];

JSONParser parser = new JSON parser();
JSONObject jsonObject = (JSONObject) parser.parse(strJsonStr);


// (2depth) 배열 핸들링 시작
JSONArray jsonArray = new JSONArray(jsonObject.get("result").toString);

/* 작성중
String[] temp = (String[]) jsonArray.toList().toArray(new String[0]);
for(String value: temp) {
    System.out.println(key + "," + newJsonObject.getString(key));
}

// 방법1
for(int i=0; i<jsonArray.length(); i++) {
    JSONObject newjsonObject = jsonArray.getJsonObject(i);

    for(String key: newJsonObject.keySey) {
        System.out.println(key + "," + newJsonObject.getString(key));
    }
}
*/
``` 

> ❗***설명***  
> 💡 2depth 형태이다.  
> 💡 비교적 간단한 형태이다. 
> 💡 위 객체로 루프 돌면서 데이터 핸들링하면 끝이다.
> 💡 이런 간단한 데이터는 따로 VO(DTO)를 사용하지 않아도 컨버트 할 필요는 없다.     



## JSON 구조가 매우 복잡한 경우 (배열,obj 로 떡칠)
### JSON 형태
```json
{
  "documnet":
  [
    "status":200,
    
    "msg":"성공",
    "result": [
      {
        "data1" :"데이터1의 값 홍길동",
        "data2" :"데이터2의 값 홍길동주소"
      }, 
      {
        "data1" :"데이터1의 값 김길동",
        "data2" :"데이터2의 값 김길동주소"
      }, 
    ],
    "language": [
      {
        "언어" :"일본어",
        "언어1" : "히라가나", 
        "언어2" : "카타카나", 
      },
      {
        "언어" :"중국어",
        "언어1" : "간체", 
        "언어2" : "번체", 
      }
    ]
  ]
}

```

> ❗***설명***  
> 💡 아까전에는 배열 형태의 객체가 한개였지만.. 복잡하게 추가되었다.  
> 💡 복잡하고 데이터 중간에 리스트이거나 , object 형 데이터가 끼어 있으면 막막하다.  


### 기존 방법대로 처리시
```java
import org.json.JSONArray;
import org.json.JSONObject;

public class JsonProcessingExample {
    public static void main(String[] args) {
        String jsonStr = "JSON 데이터 문자열"; // JSON 데이터 문자열을 여기에 입력하세요

        JSONObject jsonData = new JSONObject(jsonStr);
        JSONArray documentArray = jsonData.getJSONArray("documnet");  // 배열 JSON객체 GET

        // 배열 JSON객체 내부를 반복
        for (Object docData : documentArray) {
            JSONObject doc = (JSONObject) docData;

            int status = doc.getInt("status");
            String msg = doc.getString("msg");

            System.out.println("Status: " + status);
            System.out.println("Message: " + msg);

            JSONArray resultArray = doc.getJSONArray("result");  // 또 배열 JSON객체 GET
            for (Object resultData : resultArray) {
                JSONObject result = (JSONObject) resultData;
                String data1 = result.getString("data1");
                String data2 = result.getString("data2");

                System.out.println("Data 1: " + data1);
                System.out.println("Data 2: " + data2);
            }

            JSONArray languageArray = doc.getJSONArray("language");  // 또 배열 JSON객체 GET
            for (Object langData : languageArray) {
                JSONObject lang = (JSONObject) langData;
                String language = lang.getString("언어");
                String lang1 = lang.getString("언어1");
                String lang2 = lang.getString("언어2");

                System.out.println("언어: " + language);
                System.out.println("언어1: " + lang1);
                System.out.println("언어2: " + lang2);
            }
        }
    }
}

```

> ❗***이 코드는 사용 불가능!***  
> 💡 루트에 document 배열로 감싸져있으므로 접근 하려면 또 아래와 같이 객체를 생성하고 접근해야한다.
>   
> ```java
> JSONArray jsonArray = new JSONArray(jsonObject.get("document").toString);
> ```
>   
> 💡 위에서 language 접근 하려면 또 아래와 같이 객체를 생성하고 접근해야한다.
>   
> ```java
> JSONArray jsonArray = new JSONArray(jsonObject.get("language").toString);
> ```
> 💡 더 복잡해지면 거의 핸들링 불가능한 수준일듯..  


### STEP2. 해결법: DTO 사용하기

```java
private String id;
private Object template;
private Object status;
private List<Map> fieldList;

```

```java
String strJsonStr = [제이슨데이터];

JSONParser parser = new JSON parser();
JSONObject jsonObject = (JSONObject) parser.parse(strJsonStr);

// 테스트
//System.out.println( jsonObject.get(result).toString());  //전체구조가 출력된다.

// (3depth) 배열 핸들링 시작
JSONArray jsonArray = new JSONArray(jsonObject.get("document").toString);


for (Object : docData : documents) {

//Object 형 데이터를 다시 JSONObject 로 변환해준다.

    JSONObject doc = (JSONObject) docData;

   Map insertMap = new HashMap();

//   Gson을 이용해 형변환 진행 아래 VO 는 위에 VO 작성할때의 클래스 명이다.

   Gson gson = new Gson();

   VO documentList = gson.fromJson(doc.toString() , VO.class);

insertMap.put("documentId",documentList.getId());

​

for (Map field : documentList.getFields()){

​

  log.info("필드 id 값:"+(String) field.get("id"));

  log.info("필드 type 값:"(String) field.get("type"));

  log.info("필드 value 값:"+(String) field.get("value"));

​

   }

```










## 핸들링 기본개념  
```json
{
  "status":200,
  "msg":"성공",
  "result": [
    {
      "data1" :"데이터1의 값 홍길동",
      "data2" :"데이터2의 값 홍길동주소"
    }, 
    {
      "data1" :"데이터1의 값 김길동",
      "data2" :"데이터2의 값 김길동주소"
    }, 
  ]
}

```
> ❗***위와 같은 데이터터가 있다고 가정***  
>  
> ❗***자주 사용한 라이브러리***  
> 💡 org.json 라이브러리  
> 💡 org.json.simple 라이브러리  
> 💡 gson 라이브러리  



## JSON to Array
> ❗***설명***  
> 💡 이 로직은 JSON 객체의 특정 속성이 배열로 되어 있을 때 사용  
> 💡 JSON 배열을 Java 배열로 변환하여 사용
>   
> ❗***단점***  
> 간단하고 직관적인 방법이지만, 배열의 크기 등을 직접 다루어야 하기 때문에 조금 더 수동적인 접근이 필요.  
  
만약 JSON 데이터를 간단히 다루고자 한다면 이 로직이 더 효과적  
{: .notice--info}


### CASE1. 기본
```java
import org.json.JSONArray;
import org.json.JSONObject;

public class JsonArrayToJavaArray {
    public static void main(String[] args) {
        String jsonString = "[1, 2, 3, 4, 5]";
        JSONArray jsonArray = new JSONArray(jsonString);

        // JSONArray를 Java 배열로 변환
        Integer[] javaArray = (Integer[]) jsonArray.toList().toArray(new Integer[0]);

        // Java 배열 출력
        for (Integer value : javaArray) {
            System.out.println(value);
        }
    }
}

```

> ❗***장점***  
>   
> ```java
> JSONArray jsonArray = new JSONArray(jsonString);
> ```
>    
> 💡 위 객체로 루프 돌면서 데이터 핸들링하면 끝이다.  
> 💡 이런 간단한 데이터는 따로 VO(DTO)를 사용하지 않아도 컨버트 할 필요는 없다.  
>  
> ❗***자주 사용한 라이브러리***  
> 💡 org.json 라이브러리  
> 💡 org.json.simple 라이브러







## JSON to Map
> ❗***설명***  
> 💡 이 로직은 JSON 객체를 Java Map으로 변환하는 함수를 사용  
> 💡 더 추상화된 방법으로 JSON 데이터를 다룰 수 있어 가독성 향상  
> 💡 JSON 데이터를 Map으로 변환하여 사용하면 다양한 속성에 쉽게 접근가능  
> 💡 
>  
> ❗***단점***  
> 간단하고 직관적인 방법이지만, 배열의 크기 등을 직접 다루어야 하기 때문에 조금 더 수동적인 접근이 필요.  
  
더 복잡한 구조의 JSON 데이터를 다루거나 가독성을 높이고자 한다면 두 번째 로직이 유용  
{: .notice--info}

### STEP1. 작성중
jsonToMap(jsonObject); 로직
