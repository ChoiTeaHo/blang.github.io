---
title:  "WEB 크로스 사이트 스크립팅(XSS)"
excerpt: "WEB 크로스 사이트 스크립팅(XSS) 입니다."

categories:
  - html-css-js-jquery
tags:
  - [HTML,CSS,JS,jquery]

toc: true
toc_sticky: true

last_modified_at: 2024-12-26T20:00:00-05:00:00
---


## 요약
> ❗<span style='color:green'>***fn:escapeXml***</span>  
> 💡 <span style='color:red'>**fn:escapeXml은 <, >, &, ", ' 등을 안전한 HTML 엔티티(&lt;, &gt; 등)로 변환합니다.**</span>  
>    
> ❗<span style='color:green'><b><I>***\<c:out>***</I></b></span>  
> 💡 <span style='color:red'>**\<c:out value="${param.dataName4}" />를 사용할 경우, 기본적으로 Escape 처리가 적용됩니다.**</span>  




## XSS유형1 : (HTML태그영역) 직접 출력으로 XSS 공격 
### 문제
```java
// JAVA
model.addAttribute("dataName1", "</script><script>alert('XSS 어택1');</script><script>");

model.addAttribute("dataName2", "</script><script>alert('XSS 어택2');</script><script>");
```

```js
// html
<html>
<body>
	<!-- CASE1. c:out 이스케이프 처리 비활성화로 직접출력 공격 -->
	<c:out value="${dataName1}" escapeXml="false"/>

	<!-- CASE2. 직접출력 XSS 공격 -->
	${dataName2}
</body>
</html>

```

### 해결
```js
// html
<html>
<body>
    <!-- CASE1_해결. escapeXml 속성(이스케이프 처리) 기본값이 true이므로, 특별히 변경하지 않는 한 안전하다. -->
	<c:out value="${dataName1}"/>
	
	<!-- CASE2_해결. jstl의 escapleXml 기능을 사용한 XSS 방지  -->
	'${fn:escapeXml(dataName2)}';
</body>
</html>

```

## XSS유형2 : (스크립트영역) 스크립트 종단점을 이용한 공격
### 문제
```java
// JAVA
model.addAttribute("dataName3", "</script><script>alert('XSS 유형3 공격');</script><script>");

```

```js
// JS
<script>
    // 방법 3 : 스크립트태그의 종단점을 이용한 공격
	var data3 = ${dataName3}dddd;
</script>

```

### 해결
```js
//JS
<script>
    var data3 = '<c:out value="${dataName3}"/>';
    var data3 = '<c:out value="${fn:escapeXml(dataName3)}"/>'.replace(/'/g, "\\'");
</script>

```



## XSS 유형3 : (HTML태그영역, 스크립트영역) 쿼리스트링을 이용한 공격
### 문제
```bash
# (HTML태그영역) 브라우저 쿼리스트링입력 후 요청1
http://localhost:9090//index?dataName4=<script>alert('XSS 유형4 공격');</script>

# (스크립트영역) 브라우저 쿼리스트링입력 후 요청2
http://localhost:9090//index?dataName5=</script><script>alert('XSS 유형5 공격');</script><script>

```

```js
// html
<html>
<body>
    <!-- HTML 태그영역 -->
    <%= request.getParameter("dataName4") %>
</body>
<script>
    // 스크립트영역
    var data5 = "<%=request.getParameter("dataName5")%>";
</script>
</html>

```

### 해결
```js
// html
<html>
<body>
    <!-- HTML 태그영역 -->
    ${fn:escapeXml(param.dataName4)}
</body>
<script>
    // 스크립트영역
    // JSON 형식 유지가 필요한 경우 (예: JSON.parse)
    var data5 = JSON.parse('<%= request.getParameter("dataName5").replace(/["'\\]/g, "\\$&").replace(/\u0000/g, "\\0") %>');

    // HTML 출력이나 단순 문자열 처리로 XSS 방지가 목적인 경우
    var data5 = JSON.stringify('${fn:escapeXml(dataName5)}');

</script>
</html>

```

- JSON.stringify는 데이터 Escape를 자동으로 처리하며 JSON.parse보다 안전하게 사용할 수 있습니다.
서버에서 제공된 데이터가 JSON 형식이라면 JSON.parse를 사용, 그렇지 않으면 JSON.stringify를 사용하는 것이 좋습니다.












## 작성중
### AS-IS
```js
<script>
function injectionFilt(param) {
    param = param.replace(/</gi, "");
    param = param.replace(/>/gi, "");
    param = param.replace(/&/gi, "");
    param = param.replace(/\//gi, "");
    param = param.replace(/%/g, "");
	return param;
} 
</script>

<script>
$(document).ready(function() {
	var flag = "<%=(String) request.getParameter("otherServerData")%>";
	flag = injectionFilt(flag);
	
	if(flag == "null") {
	     //로그인페이지 이동
	} else {
	     history.replaceState({}, null, location.pathname);
	}
});
</script>

```

## 해결1
### TO-BE
```js
<script>
function escapeHtml(str) {
    return str.replace(/[&<>"']/g, function (match) {
        const escape = {
            '&': '&amp;',
            '<': '&lt;',
            '>': '&gt;',
            '"': '&quot;',
            "'": '&#039;'
        };
        return escape[match];
    });
}

function encodeUserInput(param) {
    return encodeURIComponent(param);
}

$(document).ready(function() {
    // 외부 시스템에서 전달받은 wso 파라미터를 안전하게 처리
    var flag = "<%= request.getParameter('otherServerData') %>";
    flag = escapeHtml(flag); // XSS 방지
    flag = encodeUserInput(flag); // URL 인코딩 처리

    console.log(flag); // 최종적으로 안전한 flag 값 출력

    if (flag === "null") {
        //로그인 페이지로 이동
        window.location.href = "/otp-login";
    } else {
        // 페이지 URL을 변경하여 history state 처리
        history.replaceState({}, null, location.pathname);
    }
});
</script>

```


## 보안 강화 점
### XSS 방지 강화  
> ❗<span style='color:green'><b><I>***function escapeHtml() {...} 사용***</I></b></span>  
> 💡 <span style='color:red'>**escapeHtml 함수는 HTML 특수 문자를 HTML 엔티티로 변환한다. (HTML태그 또는 스크립트 코드 실행방지 효과)**</span>  
> - <span style='color:red'> \<는 \&lt; </span>  
> - <span style='color:red'> \>는 \&gt;  </span>
>  
> 💡 <span style='color:red'>**기존 코드에서는 단순히 문자를 제거하는 방식이었으나, 이 방식은 특수 문자를 인식하고 그에 맞는 안전한 HTML 엔티티로 변환하여 출력.**</span>


### XSS 방지 강화 URL 인코딩 (encodeURIComponent 사용)  
> ❗<span style='color:green'><b><I>***URL-safe 형식으로 인코딩 효과부여***</I></b></span>  
> 💡 <span style='color:red'>**encodeURIComponent는 사용자 입력값을 URL-safe 형식으로 인코딩하여 쿼리 파라미터로 전달할 때 발생할 수 있는 문제를 방지한다.**</span>  
> - <span style='color:red'>&, =, ?, / 등의 특수 문자가 URL 내에서 잘못 처리되지 않도록 한다.</span>  
>   
> 💡 <span style='color:red'>**이 방법은 URL 파라미터가 안전하게 처리되도록 보장한다. (AS-IS에서는 URL 인코딩을 하지 않았기 때문에, URL 파라미터로 사용자 입력을 전송할 때 예상치 못한 결과가 발생할 수 있었다.)**</span>


### 기존 코드의 문제점 (filterInjectionCmd)
- filterInjectionCmd 함수는 특정 문자만 제거하여 XSS 공격을 막을 수 있는 충분한 방법이 되지 않는다.  
    - 예를 들어, 아래 코드와 같은 악성 스크립트가 제거되지 않는다. \<와 \>를 제거하는 것은 제한적인 방법이다.  
      
      ```js
      <script>alert("XSS")</script>
      ```
      
- \/나 \%와 같은 문자를 제거하는 것은 일부 특수 문자를 차단할 수 있지만, 전체적인 XSS 공격을 막는 데에는 한계가 있다.



## 해결2
### TO-BE
```js
<script>
function escapeHtml(str) {
    return str.replace(/[&<>"']/g, function (match) {
        const escape = {
            '&': '&amp;',
            '<': '&lt;',
            '>': '&gt;',
            '"': '&quot;',
            "'": '&#039;'
        };
        return escape[match];
    });
}

function encodeUserInput(param) {
    return encodeURIComponent(param);
}

$(document).ready(function() {
    // 외부 시스템에서 전달받은 wso 파라미터를 안전하게 처리
    var flag = "<%= request.getParameter('otherServerData') %>";
    flag = escapeHtml(flag); // XSS 방지
    flag = encodeUserInput(flag); // URL 인코딩 처리

    console.log(flag); // 최종적으로 안전한 flag 값 출력

    if (flag === "null") {
        //로그인 페이지로 이동
        window.location.href = "/otp-login";
    } else {
        // 페이지 URL을 변경하여 history state 처리
        history.replaceState({}, null, location.pathname);
    }
});
</script>

```